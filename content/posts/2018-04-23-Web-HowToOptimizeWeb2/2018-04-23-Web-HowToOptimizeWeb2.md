---
title : [Web] 웹사이트의 속도를 개선할 수 있는 방법 9가지 정리 - Part 2
author: Seolhun
authorURL: https://github.com/SeolHun
authorFBID: 100007393233015
date : 2018-04-23
categories : ['Web', 'Optimization']
tags : ['Web', 'Optimization', 'Cache', 'HTTP', 'gzip', 'Priority']
---

이번에는 웹사이트를 개선하기 위한 구글에서 추천하는 방법들에 간단히 정리해볼까 합니다. 서비스의 성공을 위해 이제는 프론트엔드의 중요성이 많이 커진 만큼 유저들이 불편하지 않도록 만들기 위한 웹 사이트 최적화 방법을 이해/숙지하면 큰 도움이 될 것이라 생각하였습니다.

## Intro
구글에서 잘 정리한 웹 사이트를 개선하기 위한 9가지 방법에 대해서 필요한 정보들을 모아서 정리해보는 시간을 가져볼까 합니다. 너무 잘 작성된 글이지만, 이를 한번 더 정독하면서 조금씩 정리하면 이해하고 숙지하는데 더 큰 도움이 되어 이런 시간을 가져볼까 합니다.

목차는 내용이 커질것으로 생각하여 아래와 같이 2개의 파트로 나눠서 적어볼까 합니다.
#### - [Part 1](/posts/web/20180423-web-howtooptimizeweb1/)
- 방문 페이지 리디렉션 사용 안함
- 압축 사용
- 서버 응답 시간 개선
- 브라우저 캐싱 활용

#### - [Part 2](/posts/web/20180423-web-howtooptimizeweb2/)
- 리소스 축소
- 이미지 최적화
- CSS 전송 최적화
- 표시되는 콘텐츠의 우선순위 지정
- 렌더링 차단 자바스크립트 삭제

## 5. 리소스(HTML, CSS, JS) 축소
이 규칙은 PageSpeed Insights에서 압축을 통해 리소스 중 하나의 크기를 줄일 수 있음이 감지되면 트리거됩니다.

#### - 개요
`압축은 브라우저에서 리소스를 처리하는 방식에 영향을 주지 않고 불필요하거나 중복된 데이터를 삭제하는 과정`을 말합니다. 예를 들어, 코드 주석 및 형식 지정, 사용되지 않는 코드 삭제, 더 짧은 변수와 함수 이름 사용하기 등의 과정이 있습니다.

자세한 내용은 사전 처리 및 상황별 최적화를 참조하세요.

#### - 권장사항
다음과 같이 HTML, CSS, 자바스크립트 리소스를 압축합니다.

- HTML을 압축하려면 [HTMLMinifier](https://github.com/kangax/html-minifier)를 사용해 보세요.
- CSS를 압축하려면 [CSSNano](https://github.com/ben-eb/cssnano) 및 [csso](https://github.com/css/csso)를 사용해 보세요.
- 자바스크립트를 압축하려면 [UglifyJS](https://github.com/mishoo/UglifyJS2)를 사용해 보세요. [Closure Compiler](https://developers.google.com/closure/compiler/)도 매우 효과적입니다.

<div class='text-center'>
  <img src="/images/contents/20180423/optimization/resources-zip.png" width="100%">
</div><br>

- 다른 방법으로는, [PageSpeed 모듈](https://developers.google.com/speed/pagespeed/module/)을 사용하면, Apache나 Nginx 웹 서버와 통합되어 리소스를 압축하고 사이트를 자동으로 최적화할 수 있습니다.

#### - 첨언
위와 관련된 사항들에서 Webpack을 사용하면 대부분을 해결할 수 있습니다. 위에서 언급된 라이브러리들은 대부분 Webpack Module로 제공되고 있으며, Webpack 설정에서 해당 라이브러리들을 빌드 혹은 개발시 손쉽게 설정하여 사용할 수 있습니다. 간단한 예로 [uglifyjs-webpack-plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin)를 참고하시면 이해가 빠르리라 생각합니다.

## 6. 이미지 최적화
이 규칙은 PageSpeed Insights에서 화질에 큰 영향을 주지 않고 파일 크기를 줄여서 페이지의 이미지를 최적화할 수 있음이 감지되면 트리거됩니다.

#### - 개요
이미지는 대개 페이지에 다운로드된 바이트의 대부분을 차지합니다. 따라서 이미지를 최적화하면 브라우저에서 다운로드해야 하는 바이트 수가 감소하고 클라이언트의 대역폭 경쟁이 줄어들며 브라우저가 콘텐츠를 다운로드하여 화면에 렌더링할 수 있는 속도가 빨라져서 일부 대용량 바이트를 절감하고 성능이 개선되는 경우가 많습니다.

#### - 권장사항
이미지 애셋에 가장 적합한 형식과 최적화 전략을 찾으려면 인코딩되는 데이터의 유형, 이미지 형식 기능, 화질 설정, 해상도 등을 꼼꼼히 분석해야 합니다. 또한 어떤 이미지가 벡터 형식으로 가장 잘 전송되는지, CSS를 통해 원하는 효과를 얻을 수 있는지, 각 기기 유형에 맞게 확장된 애셋을 전송하는 방법을 고려해야 합니다.

#### - `이미지 유형의 최적화(필독)`
- [반응형 이미지 전송을 위한 권장사항](https://developers.google.com/web/fundamentals/design-and-ux/responsive/images)을 따르세요.
- 각 [이미지의 이미지 최적화 검사 목록](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/image-optimization#image_optimization_checklist)을 따르세요.

#### - 첨언
이미지 최적화는 반응형/압축/파일형식에 따라 권장되는 방법이 다양합니다. 또한, 브라우저에 따라 지원되는 최신기술이 생겨나면서 이에 따라 쉽게 적용될 수 있는 부분도 증가되었습니다. 이러한 부분들알 숙지하여 개발한다면 프론트엔드 개발에서 큰 도움이 될 것입니다.

간단한 1가지를 작성하겠습니다.

> picture 요소가 브라우저에 들어가기 시작했습니다. 아직은 이 요소가 모든 브라우저에서 제공되지는 않지만, 뛰어난 이전 버전과의 호환성과 [Picturefill](https://scottjehl.github.io/picturefill/) 폴리필의 잠재적 용도가 있기 때문에 이 요소를 사용하는 것이 좋습니다.

```html
<picture>
  <source media="(min-width: 800px)" srcset="head.jpg, head-2x.jpg 2x">
  <source media="(min-width: 450px)" srcset="head-small.jpg, head-small-2x.jpg 2x">
  <img src="head-fb.jpg" srcset="head-fb-2x.jpg 2x" alt="a head carved out of wood">
</picture>
```

- 위의 예시에서 브라우저 너비가 최소 800px 이상이면 기기 해상도에 따라 head.jpg 또는 head-2x.jpg가 사용됩니다.
- 브라우저가 450px 및 800px 사이이면 다시 기기 해상도에 따라 head-small.jpg 또는 head-small-2x.jpg가 사용됩니다.
- 450px 미만인 화면 너비의 경우 picture 요소가 지원되지 않는 이전 버전과의 호환성을 위해, 브라우저는 대신 img 요소를 렌더링해야 합니다.

## 7. CSS 전송 최적화
이 규칙은 PageSpeed Insights에서 페이지에 첫 번째 렌더링 시간을 지연시키는 렌더링 차단 외부 스타일시트가 포함되어 있음이 감지되면 트리거됩니다.

#### - 개요
브라우저에서 콘텐츠를 렌더링하려면 먼저 현재 페이지의 모든 스타일과 레이아웃 정보를 처리해야 합니다. 따라서 브라우저는 외부 스타일시트가 다운로드되고 처리될 때까지 렌더링을 차단하는데, 이로 인해 왕복을 여러 번 해야 하고 첫 번째 렌더링 시간이 지연될 수 있습니다. 중요 렌더링 경로에 관해 자세히 알아보려면 [렌더링 트리 생성, 레이아웃 및 페인트](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)를 참조하세요. 또한 렌더링 차단을 해제하고 CSS 전송을 향상하는 방법에 관한 도움말은 [렌더링 차단 CSS](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css)를 참조하세요.

#### - 권장사항
외부 CSS 리소스의 크기가 작은 경우 HTML 문서에 직접 리소스를 삽입할 수 있는데, 이를 인라인이라고도 합니다. 이렇게 작은 CSS를 삽입하면 브라우저에서 페이지 렌더링을 진행할 수 있습니다. CSS 파일이 큰 경우 CSS를 전부 삽입하면 PageSpeed Insights에서 표시되는 콘텐츠의 우선순위 지정을 통해 페이지에서 스크롤 없이 볼 수 있는 부분이 너무 크다는 경고를 보낼 수 있습니다. CSS 파일이 크면 스크롤 없이 볼 수 있는 콘텐츠의 렌더링에 필요한 CSS를 확인하여 삽입한 다음 스크롤 없이 볼 수 있는 콘텐츠의 로드가 완료될 때까지 나머지 스타일의 로드를 지연시켜야 합니다.


#### - CSS의 렌더링 차단 컨트롤 하기
> CSS는 렌더링 차단 리소스입니다. 최초 렌더링에 걸리는 시간을 최적화하려면 클라이언트에 최대한 빠르게 다운로드되어야 합니다.

```html
<link href="style.css"    rel="stylesheet">
<link href="style.css"    rel="stylesheet" media="all">
<link href="portrait.css" rel="stylesheet" media="orientation:portrait">
<link href="print.css"    rel="stylesheet" media="print">
```

- 첫 번째 선언은 렌더링을 차단하고 모든 조건에서 일치합니다.
- 두 번째 선언도 렌더링을 차단합니다. `all`이 기본 유형이므로 특정 유형을 지정하지 않을 경우 암묵적으로 `all`로 설정됩니다. `따라서 첫 번째와 두 번째 선언은 사실상 똑같습니다.`
- 세 번째 선언은 페이지가 로드될 때 평가되는 동적 미디어 쿼리를 가집니다. portrait.css의 렌더링 차단 여부는 페이지가 로드되는 중에 기기의 방향에 따라 달라질 수 있습니다.
  - 가로방향일 때는 landscape를, 세로방향일 땐 portrait를 지정할 시 true를 반환합니다.
- 마지막 선언은 페이지가 인쇄될 때만 적용됩니다. 따라서 페이지가 브라우저에서 처음 로드될 때는 렌더링이 차단되지 않습니다.

#### - `필독 사항`
HTML 및 CSS 입력을 기반으로 DOM 및 CSSOM 트리를 빌드되며, 이들 모두 문서의 각기 다른 측면을 캡처하는 서로 독립적인 객체입니다. 하나는 콘텐츠를 설명하고, 다른 하나는 문서에 적용되어야 하는 스타일 규칙을 설명합니다. 이 두 가지를 병합하여 브라우저가 화면에 픽셀을 렌더링하도록 하려면 어떻게 해야 할까요?

1. HTML 마크업을 처리하고 DOM 트리를 빌드합니다.
2. CSS 마크업을 처리하고 CSSOM 트리를 빌드합니다.
3. `DOM 및 CSSOM을 결합하여 렌더링 트리를 형성`합니다.
  - 렌더링 트리를 생성하려면 브라우저가 대략적으로 다음 작업을 수행합니다.
    1. DOM 트리의 루트에서 시작하여 표시되는 노드 각각을 트래버스합니다.
      - 일부 노드는 표시되지 않으며(예: 스크립트 태그, 메타 태그 등), 렌더링된 출력에 반영되지 않으므로 생략됩니다.
      - 일부 노드는 CSS를 통해 숨겨지며 렌더링 트리에서도 생략됩니다.
        - 예를 들어, span 노드의 경우 'display: none' 속성을 설정하는 명시적 규칙이 있기 때문에 렌더링 트리에서 누락됩니다.
4. 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산합니다.
5. 마지막 단계는 최종 렌더링 트리에서 수행되는 페인트이며, 픽셀을 화면에 렌더링합니다.

<img src="/images/contents/20180423/optimization/render-tree.png" width="100%">

## 8. 표시되는 컨텐츠 우선순위 지정
이 규칙은 PageSpeed Insights에서 페이지의 스크롤 없이 볼 수 있는 콘텐츠를 렌더링하는 데 추가적인 네트워크 왕복이 필요함이 감지되면 트리거됩니다.

#### - 개요
필요한 데이터 양이 초기 혼잡 윈도우(일반적으로 14.6 KB 압축)를 초과하면 서버와 사용자 브라우저 간에 추가 왕복이 필요합니다. 모바일 네트워크와 같이 지연 시간이 긴 네트워크를 사용하는 사용자의 경우 이로 인해 페이지 로드가 크게 지연될 수 있습니다.

#### - 권장사항
페이지 로드 속도를 높이려면 페이지에서 스크롤 없이 볼 수 있는 콘텐츠를 렌더링하는 데 필요한 데이터(HTML 마크업, 이미지, CSS, 자바스크립트)의 크기를 제한하세요. 몇 가지 방법은 다음과 같습니다.

##### 1. 스크롤 없이 볼 수 있는 중요한 콘텐츠를 먼저 로드하도록 HTML 구성
페이지의 주요 콘텐츠를 먼저 로드하세요. 서버의 초기 응답에서 페이지의 중요한 부분을 렌더링하는 데 필요한 데이터를 즉시 보내고 나머지를 지연하도록 페이지를 구성하세요. 이렇게 구성하려면 CSS를 두 부분, 즉 콘텐츠 중 ATF 부분의 스타일 지정을 담당하는 인라인 부분과 지연해도 되는 부분으로 분할해야 할 수 있습니다.

사이트의 로드 속도를 높이기 위해 재구성하는 방법에 관한 다음 예를 고려하세요.

- HTML에서 제3자 위젯을 로드한 후 주요 콘텐츠를 로드하는 경우 주요 콘텐츠를 먼저 로드하도록 순서를 변경합니다.
- 사이트에서 탐색 사이드바와 자료가 포함된 2열 디자인을 사용하는데 HTML에서 사이드바를 내용보다 먼저 로드하는 경우 내용을 먼저 로드해 보세요.

##### 2. 리소스에서 사용하는 데이터의 양 축소
사이트를 여러 기기에서 잘 작동하고 중요한 콘텐츠를 먼저 로드하도록 다시 디자인했으면 다음 기술을 사용하여 페이지 렌더링에 필요한 데이터의 양을 줄입니다.

- 리소스 축소 : 불필요한 공백과 주석을 삭제하면 HTML, CSS, 자바스크립트를 축소할 수 있습니다.
  - 리소스의 변수 이름을 변경하는 도구를 사용하여 세부적으로 최적화할 수 있습니다.
- 가능하면 이미지 대신 CSS 사용
- 압축 사용

## 9. 렌더링 차단 자바스크립트 삭제
이 규칙은 HTML이 페이지의 스크롤 없이 볼 수 있는 부분에 있는 외부 차단 자바스크립트 파일을 참조하는 것이 PageSpeed Insights에서 감지하면 트리거됩니다.

#### - 개요
브라우저가 페이지를 렌더링하려면 먼저 HTML 마크업을 파싱하여 DOM을 빌드해야 합니다. 처리되는 동안 파서에서는 스크립트를 발견할 때마다 파싱을 중지하고 스크립트를 실행해야 HTML을 계속 파싱할 수 있습니다. 또한 외부 스크립트의 경우 파서에서는 리소스가 다운로드될 때까지 기다려야 하며, 이로 인해 한 번 이상의 네트워크 왕복이 발생하고 페이지의 첫 렌더링 시간이 지연될 수 있습니다. 자바스크립트가 중요한 렌더링 경로에 어떻게 영향을 미치는지 자세히 알아보려면[ 자바스크립트로 상호작용 추가](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript)를 참조하세요.

- 자바스크립트는 DOM 및 CSSOM을 쿼리하고 수정할 수 있습니다.
- 자바스크립트 실행은 CSSOM을 차단합니다.
- 자바스크립트는 명시적으로 비동기로 선언되지 않은 경우 DOM 생성을 차단합니다.

#### - 권장사항
차단 자바스크립트의, 특히 실행하기 전에 가져와야 하는 외부 스크립트의 사용을 피하고 최소화해야 합니다. 추가적인 네트워크 요청을 방지하기 위해 페이지 콘텐츠를 렌더링하는 데 필수적인 스크립트를 인라인으로 삽입할 수도 있지만, 좋은 성능을 내려면 인라인 콘텐츠는 크기가 작아야 하고 빠르게 실행할 수 있어야 합니다. 첫 렌더링에서 중요하지 않은 스크립트는 비동기 스크립트로 생성하거나 첫 번째 렌더링이 완료될 때까지 지연되어야 합니다. 또한 이 경우 로드 시간을 향상하려면 CSS 전송을 최적화 해야 합니다.

#### - `필독사항`
스크립트를 실행하려는 경우 브라우저가 CSSOM을 다운로드하고 빌드하는 작업을 완료하지 않았으면 어떻게 될까요? 답은 간단하지만 성능에는 그다지 좋지 않습니다. `브라우저가 CSSOM을 다운로드하고 생성하는 작업을 완료할 때까지 스크립트 실행 및 DOM 생성을 지연시킵니다.`

간단히 말해서, 자바스크립트에서는 DOM, CSSOM 및 자바스크립트 실행 간에 여러 가지 새로운 종속성을 도입합니다. 이 때문에 브라우저가 화면에서 페이지를 처리하고 렌더링할 때 상당한 지연이 발생할 수 있습니다.

- 문서에서 스크립트의 위치는 중요합니다.
- 브라우저가 스크립트 태그를 만나면 이 스크립트가 실행 종료될 때까지 DOM 생성이 일시 중지됩니다.
- 자바스크립트는 DOM 및 CSSOM을 쿼리하고 수정할 수 있습니다.
- 자바스크립트 실행은 CSSOM이 준비될 때까지 일시 중지됩니다.

##### - \<script\> 태그와 인라인 Javascript snippet 차이
대부분이 \<script\> 태그를 사용하든 인라인 자바스크립트 스니펫을 사용하든 간에 여러분은 이 둘이 동일한 방식으로 동작할 것으로 기대합니다. 두 경우 모두 브라우저가 일시 중지하고 스크립트를 실행해야만 문서의 나머지 부분을 처리할 수 있습니다.

하지만, `외부 자바스크립트 파일의 경우 브라우저가 일시 중지하고 디스크, 캐시 또는 원격 서버에서 스크립트를 가져올 때까지 기다려야 합니다.` 이로 인해 주요 렌더링 경로에 수십 ~ 수천 밀리초의 지연이 추가로 발생할 수 있습니다. 이러한 것을 방지하기 위해 비동기로 외부 JS를 로드할 수 있습니다.

##### - 자바스크립트를 `비동기(async)`로 생성
```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path: Script Async</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
    <script src="app.js" async></script>
  </body>
</html>
```

위의 예시처럼, `async` 키워드를 스크립트 태그에 추가하면, 스크립트가 사용 가능해질 때까지 기다리는 동안 DOM 생성을 차단하지 말라고 브라우저에 지시하는 것입니다. 이 경우 성능이 크게 향상됩니다.

## Outro
개인적으로 웹 개발에서의 가장 큰 어려움은 브라우저 별 차이점에서 발생하는 것 같다고 생각합니다. 하지만, HTTP와 같은 표준을 준수하여 개발한다면 옛 브라우저 외에는 대부분의 브라우저가 표준을 따라가고 있기 때문에 큰 어려움없이 개발 간 문제에 대처할 수 있을것으로 판단합니다.

특히, Resources를 잘 관리하는 것이 웹 페이지를 최적화하는데 중요한 요소로 보입니다. 또한, 브라우저의 간단한 작동원리를 이해해야 할 필요가 있습니다. CSS 경우는 렌더링 트리를 만들기 위해서 로드 전까지 렌더링을 차단하는, JS는 DOM생성을 차단하는 특징을 확인할 수 있었습니다. 이러한 브라우저의 작동 흐름을 이해한다면 해당 코드들을 분리하고 필요한 경우에 따라서 이를 응용하여 최적화하는데 큰 도움이 될 것으로 생각합니다.

이번내용은 Frontend 관련 내용이 많다고 생각합니다. Resources 관리부터 압축, 최적화 등 다양한 기능들은 현재 Webpack Bundler를 통해 해결할 수 있습니다. 하지만, 프로젝트가 커지면 분리해야되는 부분이 생기기 때문에 이를 100% 규칙적으로 따라갈수는 없다고 생각합니다. 하지만, 이러한 내용을 숙지한다면 웹 최적화를 고려한 개발할 수 있다고 생각합니다.

## References
- [Google PageSpeed Insights](https://developers.google.com/speed/docs/insights/rules)
