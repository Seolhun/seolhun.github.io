{"componentChunkName":"component---src-templates-tag-tsx","path":"/tags/network","webpackCompilationHash":"117d25e214ca6ce1b042","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"posts":[{"excerpt":"이번에는 Http와 Https에 대한 정의와 간단한 차이점에 대해서 정리해보고자 합니다. Intro Let's Encrypt를 사용하여 개인 Domain에 Https를 적용한 적이 있습니다.…","html":"<p>이번에는 Http와 Https에 대한 정의와 간단한 차이점에 대해서 정리해보고자 합니다.</p>\n<h2 id=\"intro\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p><a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Let's Encrypt</a>를 사용하여 개인 Domain에 Https를 적용한 적이 있습니다. 3개월 동안 무료로 사용할 수 있으며 이후에 수동으로 다시 갱신해야 합니다. 간단한 로직과 함게 크론을 사용하면 갱신도 자동적으로 하여 사용할 수 있습니다. 무료로서 개인 도메인으로 사용하기에는 적합하지만, 엔터프라이즈에서 사용하기에는 보안수준이 낮아 비용을 지불해서라도 더 좋은 서비스를 이용해야 할 것입니다.</p>\n<p>이와 더불어 함게 사용되는 툴이 <a href=\"https://www.wireshark.org/download.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Wireshark</a>입니다. 해당 도메인에서 발생되는 패킷을 확인할 수 있으며, 필터링을 통해 원하는 것만을 필터링 할수도 있습니다.</p>\n<p>이렇게 2가지를 언급하는 이유는 https는 즉, 네트워크에서 전송되는 패킷을 암호화하여 이를 쉽게 해독할 수 없도록 만들어줍니다. http에서 해당 패킷을 확인해보고, https 적용 후 패킷을 다시 확인해보면 그 차이를 크게 확인 할 수 있습니다.</p>\n<img src=\"/images/contents/20180420/http/http.png\" width=\"100%\">\n<h2 id=\"httphypertext-transfer-protocol\"><a href=\"#httphypertext-transfer-protocol\" aria-label=\"httphypertext transfer protocol permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP(HyperText Transfer Protocol)</h2>\n<p><code class=\"language-text\">HTTP(HyperText Transfer Protocol)</code>는 WWW 상에서 정보를 주고받을 수 있는 프로토콜입니다. 주로 HTML 문서를 주고받는 데에 쓰입니다. TCP와 UDP를 사용하며, 기본 TCP/IP 포트는 80 포트를 사용합니다. 1996년에 첫 상용화버전인 HTTP/1.0가 발표되었고, 1999년에 HTTP/1.1, 그리고 2015년 HTTP/2를 공식으로 발표하였습니다.</p>\n<p>HTTP에 대해 더 간단히 설명하자면, HTTP는 요청(Request)와 응답(Response)로 구성되어 있고, 클라이언트가 요청을 하면 서버가 응답을 하는 구조로 되어 있습니다. <code class=\"language-text\">HTTP는 FTP나 텔넷과는 다르게 비연결식입니다.</code> FTP나 Telnet은 클라이언트가 서버에 정보를 요청해도 서버가 클라이언트와 연결을 끊지 않지만, <code class=\"language-text\">HTTP는 클라이언트가 서버에 정보를 요청하면 응답 코드와 내용을 전송하고 클라이언트와 연결을 종료합니다.</code> 즉, 요청과 응답이 하나의 연결로 이어지지 않고 요청에 따른 응답에으로 2가지 작업으로 진행됩니다.</p>\n<p>이러한 HTTP 특징으로 HTTPS를 들어가기 전에 알 필요가 있는 <code class=\"language-text\">Packet</code>에 대해서 알아보겠습니다.</p>\n<h2 id=\"packet\"><a href=\"#packet\" aria-label=\"packet permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Packet</h2>\n<p>Packet이란?, Package(화물)와 Bucket(덩어리)의 합성어입니다. 즉, WWW Web에서는 전송될 때, 서로 교환되는 실제의 내용물로 분할된 파일 데이터에 주소와 에러 데이터 등이 기록됩니다. '분할'의 특성 때문에 자연스럽게 시분할(Time-slice) 방식으로 처리가 가능한 특징을 가지고 있어, 선이 끊기면 연결성이 끊어지는 서킷 방식과는 다르게 양측 단말의 길만 정해지면 언제든지 우회가 가능하다는 장점이 있습니다. 또한, 중간에 분실한 패킷에 대해서는 그 부분만 다시 보내면 문제되지 않기 때문에 인터넷은 물론 허브 역시 패킷 방식을 사용합니다. 다만, 이러한 작업을 위해 패킷에 고유의 번호를 매겨야 하고, 이 순서를 양측이 동일하게 사용해야 한다는 단점이 있습니다.</p>\n<p>이러한 문제를 해결하기 위해 제약사항 등을 포함한 통신 규칙, 즉 프로토콜이 등장한 것입니다. TCP/IP 등 신뢰성 기반의 프로토콜(HTTP 등)은 대부분 이러한 기능을 지니고 있습니다. <strong>간단히 말해, '택배에 송장 번호를 매긴다' 생각하면 편하게 이해할 수 있습니다.</strong></p>\n<h2 id=\"httpshypertext-transfer-protocol-security---over-tls-ssl-http-secure\"><a href=\"#httpshypertext-transfer-protocol-security---over-tls-ssl-http-secure\" aria-label=\"httpshypertext transfer protocol security   over tls ssl http secure permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS(HyperText Transfer Protocol Security - over TLS, SSL, HTTP Secure)</h2>\n<p><code class=\"language-text\">HTTPS(Hypertext Transfer Protocol over Secure Socket Layer)</code>는 월드 와이드 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전입니다. HTTPS는 통신의 인증과 암호화를 위해 넷스케이프 커뮤니케이션즈 코퍼레이션이 개발했습니다. HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화합니다. 따라서 데이터의 적절한 보호를 보장합니다. HTTPS의 기본 TCP/IP 포트는 443을 이용합니다. HTTPS의 보안수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려다고 할 수 있습니다.</p>\n<p>위에서 간단히 언급했듯이, HTTPS는 패킷이 암호화되어 있기 때문에 패킷캡쳐(WireShark와 같은) 프로그램으로 사용해서 패킷의 내용을 보더라도 암호화된 내용만 보이게 됩니다. 암호화는 TLS라고 하여 OSI7계층에서 L4의 전송계층(Transport)에서 이루어지게 됩니다. 이러한 암호화 과정을 거치기 때문에 HTTPS는 HTTP보다 느리지만, 현재 인터넷 속도에서 이는 큰 의미가 없습니다. 그리고 HTTPS는 개인정보가 거래되는 웹 상에서는 의무화되어있습니다.</p>\n<h2 id=\"sslsecure-sockets-layer\"><a href=\"#sslsecure-sockets-layer\" aria-label=\"sslsecure sockets layer permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL(Secure Sockets Layer)</h2>\n<p>SSL은 Secure Sockets Layer를 의미하며 이는 웹 브라우저와 엡 서버 사이에 암호화된 통신을 구현하는 글로벌 표준 보안 기술입니다. 요약하자면, <code class=\"language-text\">SSL은 두 의도된 당사자들만의 사적인 &quot;대화&quot;를 가능하게 해 줍니다.</code> 이 보안 연결을 설정하기 위해, SSL 인증서(디지털 인증서라 하기도 함)가 웹 서버에 설치되어 다음 두 가지 기능을 수행합니다.</p>\n<ol>\n<li>웹사이트의 신원을 인증(방문자에게 해당 사이트가 위조 사이트가 아님을 보장)</li>\n<li>전송되는 데이터를 암호화</li>\n</ol>\n<h2 id=\"tlstransport-layer-security\"><a href=\"#tlstransport-layer-security\" aria-label=\"tlstransport layer security permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLS(Transport Layer Security)</h2>\n<p>인터넷을 사용한 통신에서 보안을 확보하려면 두 통신 당사자가 서로가 신뢰할 수 있는 자임을 확인할 수 있어야 하며, 서로간의 통신 내용이 제3자에 의해 도청되는 것을 방지해야 합니다. 따라서 <code class=\"language-text\">서로 자신을 신뢰할 수 있음을 알리기 위해 전자 서명이 포함된 인증서를 사용하며, 도청을 방지하기 위해 통신 내용을 암호화</code>합니다. 이러한 통신 규약을 묶어 정리한 것이 바로 TLS이며, 주요 웹브라우저 주소창에 자물쇠 아이콘이 뜨는 것으로 TLS의 적용 여부를 확인할 수 있습니다.</p>\n<p>간단한 예를 들어, 인터넷 뱅킹을 하기 위해 은행의 사이트에 방문했을 때, 고객은 그 사이트가 정말 은행의 사이트가 맞는지 아니면 해커가 만든 가짜 피싱 사이트인지 확인할 수 있어야 하며, 은행 역시 자신의 서비스에 접속한자가 해당 고객이 맞는지 아니면 고객의 컴퓨터와 서버 사이에서 내용을 가로채고자 하는 해커인지 확인할 수 있어야 합니다. 그리고 은행과 고객 간의 통신 내용이 다른 해커에게 도청되지 않도록 내용을 숨겨야 합니다. 이럴 때 바로 은행과 고객 간에 TLS를 사용한 연결을 맺어 안전하게 통신을 할 수 있습니다.</p>\n<h2 id=\"tls-handshaking\"><a href=\"#tls-handshaking\" aria-label=\"tls handshaking permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLS HandShaking</h2>\n<ol>\n<li>먼저, 클라이언트에서 서버에 ClientHello 메시지를 보낸다. 여기에는 클라이언트에서 가능한 TLS 버전, 세션 식별자, 암호 설정 등의 정보가 포함된다.</li>\n<li>클라이언트의 메시지를 받은 서버는 ServerHello 메시지를 클라이언트에게 보낸다. 여기에는 ClientHello 메시지의 정보 중 서버에서 사용하기로 선택한 TLS 버전, 세션 식별자, 암호 설정 등의 정보가 포함된다.</li>\n<li>서버가 클라이언트에 Certificate 메시지를 보낸다. 여기에는 서버의 인증서가 들어간다. 이 인증서는 별도의 인증 기관에서 발급받은 것이며, 서버가 신뢰할 수 있는 자임을 인증한다. 전송이 끝나면 ServerHelloDone 메시지를 보내 끝났음을 알린다.</li>\n<li>클라이언트는 서버에서 받은 인증서를 검증한다. 인증서의 유효 기간이 만료되지 않았는지, 그 인증서가 해당 서버에게 발급된 인증서가 맞는지 등을 확인한다. 인증서를 신뢰할 수 있다고 판단하였다면 다음 단계로 넘어간다.</li>\n<li>클라이언트는 임의의 pre-master secret을 생성한 뒤, 서버가 보낸 인증서에 포함된 공개 키를 사용해 암호화한다. 이렇게 암호화된 pre-master secret을 ClientKeyExchange 메시지에 포함시켜 서버에 전송한다.</li>\n<li>서버는 전송받은 정보를 복호화하여 pre-master secret을 알아낸 뒤, 이 정보를 사용해 master secret을 생성한다. 그 뒤 master secret에서 세션 키를 생성해내며, 이 세션 키는 앞으로 서버와 클라이언트 간의 통신을 암호화하는데 사용할 것이다. 물론 클라이언트 역시 자신이 만들어낸 pre-master secret을 알고 있으므로, 같은 과정을 거쳐 세션 키를 스스로 만들 수 있다.</li>\n<li>이제 서버와 클라이언트는 각자 동일한 세션 키를 가지고 있으며, 이를 사용해 대칭 키 암호를 사용하는 통신을 할 수 있다. 따라서 우선 서로에게 ChangeCipherSpec 메시지를 보내 앞으로의 모든 통신 내용은 세션 키를 사용해 암호화해 보낼 것을 알려준 뒤, Finished 메시지를 보내 각자의 핸드셰이킹 과정이 끝났음을 알린다.</li>\n<li>이제 서버와 클라이언트 간에 보안 통신이 구성된다.</li>\n</ol>\n<p>쉽게 요약해서, 먼저 서로가 어떤 TLS 버전을 사용 가능한지를 확인하고, 인증서를 사용해 서로를 믿을 수 있는지 확인한 뒤, 서로간의 통신에 쓸 암호를 교환하는 것입니다.</p>\n<h2 id=\"outro\"><a href=\"#outro\" aria-label=\"outro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Outro</h2>\n<p>HTTP의 특징처럼 전송/응답의 환경에서 Packet을 통해 해당 데이터를 전송받고 응답할 수 있습니다. 즉, HTTPS는 이러한 HTTP 환경에 전송/응답되는 데이터를 암호화하는 처리를 추가적으로 해주는 것입니다. 이 외에도 신뢰성 있는 3자를 통해 클라이언트와 서버 간의 신뢰성을 확보할 수 있도록 도와주는 인증과정을 확인할 수 있습니다. 이 외에도 HTTP를 통해 전송되는 Packet과 암호화 과정의 방법인 TLS, SSL 등에 대해서 알아볼 수 있었습니다. 부족한 내용도 많지만, 간단하게 알아봄으로써 그 둘의 차이를 알 수 있었다고 생각합니다.</p>\n<p>제가 생각하는 HTTP와 HTTPS의 가장 큰 차이는 즉, <code class=\"language-text\">HTTP의 전송/응답 데이터를 암호화 하는 것</code>이라고 생각합니다. TLS는 OSI 7계층 중 L4 Transport 게층에서, SSL은 응용계층과 전송계층 사이에 독립적인 프로토콜 계층을 만들어서 동작합니다. HTTPS에는 이 외에도 많은 기능이 있겠지만, OSI 7계층과 함께 이해한다면 좋은 내용이 될 것이라고 판단합니다. 다음에는 OSI 7계층에 대해서도 간단히 정리해봐야 할 것 같습니다. 감사합니다.</p>\n<h2 id=\"references\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/HTTP\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WIKI - HTTP</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/HTTPS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WIKI - HTTPS</a></li>\n<li><a href=\"https://namu.wiki/w/TLS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WIKI - TLS</a></li>\n<li><a href=\"https://www.verisign.com/ko_KR/website-presence/website-optimization/ssl-certificates/index.xhtml\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Versign - SSL</a></li>\n</ul>","id":"12f3407a-3398-5b44-9051-8d4f0cd92303","fields":{"slug":"network-http-http-vs-https의-차이-그리고-packet과-tsl-ssl"},"frontmatter":{"title":"[Network/Http] Http vs Https의 차이? 그리고 Packet과 TSL, SSL","date":"2018-04-20T00:00:00.000Z","author":"Seolhun","subTitle":"","banner":"/assets/covers/http.png","category":"Network","tags":["Network","Http","Https","Packet","TLS","SSL"]},"timeToRead":5},{"excerpt":"이번에는 에 대해서 간단히 정리해볼까 합니다. 개인적으로는 Spring에서 Stomp와 SockJS를 이용해서 사용해본 경험이 있고, 최근에는 NodeJS에서 SocketIO를 이용하였습니다. 이용하여 성공적으로 개발하는 것도 중요하지만, 더 중요한 것은 기술에 대한 개념적인 이해라고 생각하여 이번에 정리하는 시간을 가져보았습니다. Intro 먼저, 네이버 D2 블로그와 Wikipedia와 Mozilla…","html":"<p>이번에는 <code class=\"language-text\">WebSocket</code>에 대해서 간단히 정리해볼까 합니다.</p>\n<p>개인적으로는 Spring에서 Stomp와 SockJS를 이용해서 사용해본 경험이 있고, 최근에는 NodeJS에서 SocketIO를 이용하였습니다. 이용하여 성공적으로 개발하는 것도 중요하지만, 더 중요한 것은 기술에 대한 개념적인 이해라고 생각하여 이번에 정리하는 시간을 가져보았습니다.</p>\n<h2 id=\"intro\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>먼저, 네이버 D2 블로그와 Wikipedia와 Mozilla 등의 사이트를 많이 참고하면서 내용을 정리했습니다. 좋은 정보에 감사의 말씀드립니다.</p>\n<p>개인적으로 WebSocket을 이용했던 부분은 웹사이트에서 일어나는 이벤트에 대해 관련 대상자에게 실시간으로 알림을 알려주는 서비스였습니다. 예를 들어, 게시판 댓글 등의 작업이 이루어지면 글 작성자에게 관련된 메세지를 실시간으로 알려주는 알림 서비스였습니다. 특히, 이 부분에서 어려웠던 것은 대상자를 찾아내어 해당 메세지 구독자에게 메세지를 보내는 것이었습니다. 처음 문서를 읽었을 때 정확히 이해하는 것이 힘들었지만, Spring에서 Security Session의 값을 이용하여 서버 내 Client를 추적할 수 있어서 이 부분을 어렵지 않게 해결할 수 있었습니다.</p>\n<p>하지만, 중요한 것은 개발 과정에서 WebSocket과 Stomp의 작동원리를 정확히 이해하여 Session 관련된 컨트롤이 요구될 때마다 많은 어려움이 있었습니다. 그 외에도 페이스북에서는 브라우저 호환성 때문에 Polling을 이용한다는 개발자의 글도 보면서 다양한 환경에 대한 안전장치가 잘 되어있는지를 체크하여 확인하는 것이 중요하다고 생각했습니다. 이러한 일련의 과정을 간단하게 정리하여 WebSocket을 정리해볼까 합니다.</p>\n<h4 id=\"--content-list\"><a href=\"#--content-list\" aria-label=\"  content list permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>- Content List</h4>\n<ol>\n<li>Websocket이란?</li>\n<li>WebSocket과 Polling 방식의 차이는 무엇인가?</li>\n<li>WebSocket의 브라우저 호환성</li>\n<li>SocketIO란?</li>\n</ol>\n<h2 id=\"1-websocket이란\"><a href=\"#1-websocket%EC%9D%B4%EB%9E%80\" aria-label=\"1 websocket이란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. WebSocket이란?</h2>\n<blockquote>\n<p>웹소켓(WebSocket)은 하나의 TCP 접속에 전이중 통신 채널을 제공하는 컴퓨터 통신 프로토콜입니다. 2008년 6월, 일련의 토론이 마이클 카터(Michael Carter)에 의해 주도되어 웹소켓으로 알려진 최초 버전의 프로토콜이 탄생하였습니다. 이후 TCP 기반 소켓 API를 대체할 목적으로 HTML5 사양에서 TCPConnection으로 처음 참조되었습니다. 웹소켓 프로토콜은 2011년 IETF에 의해 RFC 6455로 표준화되었으며 웹 IDL의 웹소켓 API는 W3C에 의해 현재 HTML5에 표준화되었습니다.</p>\n</blockquote>\n<p>사전적 정의처럼 WebSocket은 하나의 프로토콜로서 TCP를 이용하여 데이터를 실시간으로 양뱡향 통신을 할 수 있게 만든 기술입니다. 원래 Socket의 의미가 TCP/IP를 연결하여 기능을 제공하는 하나의 인터페이스라고 할 수 있는데, 이를 웹에서도 가능하게 만들어 준 것입니다. 원래 Web 환경은 필요한 정보를 HTTP 기반으로 Request/Response로 연결하여 데이터를 주고 받아 네트워크의 연결을 유지하지 않는 특징을 가지고 있습니다. 이러한 환경에서 웹의 환경이 더욱 성장하면서 Socket Programming처럼 실시간으로 데이터를 주고받기 위한 노력이 많이 이루어졌습니다.</p>\n<ul>\n<li>추가사항\nHTML과 HTTP를 찾아서 읽어보면 도움이 될 것 같습니다. - <a href=\"https://ko.wikipedia.org/wiki/HTTP\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HTTP - WikiPedia</a></li>\n</ul>\n<blockquote>\n<p>팀 버너스 리와 그의 팀은 CERN에서 HTML뿐 아니라 웹 브라우저 및 텍스트 기반 웹 브라우저 관련 기술과 더불어 오리지널 HTTP을 발명하였다. 버너스 리는 최초로 \"월드와이드웹\" 프로젝트를 1989년에 제안하였으며, 이것이 현재의 월드 와이드 웹이다. 이 프로토콜의 최초 버전은 서버로부터 페이지를 요청하는 GET이라는 이름의 하나의 메소드만 있었다. 서버로부터의 응답은 무조건 HTML 문서였다.</p>\n</blockquote>\n<h2 id=\"2-websocket과-polling-방식의-차이는-무엇인가\"><a href=\"#2-websocket%EA%B3%BC-polling-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"2 websocket과 polling 방식의 차이는 무엇인가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. WebSocket과 Polling 방식의 차이는 무엇인가?</h2>\n<p>위에서도 언급했듯이 Web에서 실시간으로 데이터를 받아야하는 노력이 많이 이루어졌습니다. 특히, 초기에는 XHR(ajax)와 같은 기술의 등장으로 이를 이용하여 이벤트를 지속적으로 발생/교환하여 실시간처럼 작동하는 Polling 방식이 대표적이었습니다. 하지만, 연결할 때마다 Header 값을 보내고 이를 컨트롤하는 로직들이 많이 발생되면서 비효율적인 문제들이 발생하였습니다.</p>\n<p>이를 해결하기 위해 등장한 것이 바로 WebSocket입니다. WebSocket은 한 번의 HandShake를 통해 필요한 정보를 확인한 후 Client와 Server간의 Socket을 연결합니다. 이후 Socket을 통해 필요한 정보를 쉽게 실시간으로 주고받아 효율적으로 데이터를 전송/수신 할 수 있습니다. 간단하게 그림을 통해 비교하면 더 이해하기 쉽습니다.</p>\n<h4 id=\"--polling-flow\"><a href=\"#--polling-flow\" aria-label=\"  polling flow permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>- Polling Flow</h4>\n<div class='text-center'>\n  <img src='/assets/images/contents/20180413/websocket/polling.png' width='100%'>\n</div>\n<h4 id=\"--websocket-flow\"><a href=\"#--websocket-flow\" aria-label=\"  websocket flow permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>- WebSocket Flow</h4>\n<div class='text-center'>\n  <img src='/assets/images/contents/20180413/websocket/websocket.png' width='50%'>\n</div>\n<h4 id=\"--websocket의-handshake-과정\"><a href=\"#--websocket%EC%9D%98-handshake-%EA%B3%BC%EC%A0%95\" aria-label=\"  websocket의 handshake 과정 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>- WebSocket의 HandShake 과정</h4>\n<p>WebSocket은 HandShake를 통해 Client와 Server 접속을 유지합니다. 아래 WebSocket 관련한 그림을 살펴보면 이해하기가 더 쉽습니다.</p>\n<p>Client에서 랜덤하게 생성된 키 값을 전송하고 Server는 이 키 값을 바탕으로 토큰을 생성하여 Client에게 Response 보내어 Client와 Server간의 HandShaking이 이루어집니다. 이러한 HandShaking 과정을 통해 연결을 유지하기 때문에 방화벽 등의 환경에서도 문제 없이 연결을 유지할 수 있습니다.</p>\n<h5 id=\"--클라이언트-요청\"><a href=\"#--%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%9A%94%EC%B2%AD\" aria-label=\"  클라이언트 요청 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>- 클라이언트 요청</h5>\n<p>HTTP 버전은 반드시 1.1. 혹은 그 이상이어하며, 반드시 GET 방식이어야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">GET /chat HTTP/1.1\nHost: example.com:8000\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: <span class=\"token assign-left variable\">dGhlIHNhbXBsZSBub25jZQ</span><span class=\"token operator\">==</span>\nSec-WebSocket-Version: <span class=\"token number\">13</span></code></pre></div>\n<h5 id=\"--서버-응답\"><a href=\"#--%EC%84%9C%EB%B2%84-%EC%9D%91%EB%8B%B5\" aria-label=\"  서버 응답 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>- 서버 응답</h5>\n<p>각각의 헤더 끝에는 \\r\\n을 그리고 가장 마지막에는 한번 더 \\r\\n을 넣어야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">HTTP/1.1 <span class=\"token number\">101</span> Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo<span class=\"token operator\">=</span></code></pre></div>\n<h2 id=\"3-websocket의-브라우저-호환성\"><a href=\"#3-websocket%EC%9D%98-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%ED%98%B8%ED%99%98%EC%84%B1\" aria-label=\"3 websocket의 브라우저 호환성 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. WebSocket의 브라우저 호환성</h2>\n<p>이 장에서 중요한 것은 WebSocket의 브라우저 호환성 문제입니다. WebSocket의 브라우저 호환성 표를 보겠습니다.</p>\n<div class='text-center'>\n  <img src='/assets/images/contents/20180413/websocket/supported-browser.png' width='100%'>\n</div>\n<p>브라우저 호환성이 중요한 이유는 Client에서 WebSocket이 연결되는 것은 브라우저입니다. 즉, 브라우저에서 WebSocket을 지원하지 않으면 서버가 않으면 이용할 수 없습니다. 이러한 브라우저 호환성 문제로 인해 개발자 커뮤니티에서 페이스북 개발자가 직접 페이스북 서비스에서 Polling 방식으로 개발한 이유에 대한 글을 본적이 있습니다. 이처럼 WebSocket은 브라우저 호환성이라는 제약사항을 갖고 있어 모든 유저의 환경을 고려한 대중적인 서비스를 개발하기 위해서는 아직도 해결해야 할 많은 이슈들이 존재합니다.</p>\n<p>하지만, 이러한 문제를 해결할 수 있는 오픈소스가 존재합니다. 2가지 얘기해보면, 개인적으로 처음 사용했던 <a href=\"https://github.com/sockjs/sockjs-client\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SockJS</a>라는 것이 있습니다. Spring 문서에서도 언급되며 브라우저의 호환성을 해결해줍니다. SockJS보다 많은 사람이 이용하는 것은 <a href=\"https://socket.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SocketIO</a>란 것입니다. NodeJS로 구축되었고, 다양한 언어로도 구현되어 쉽게 사용할 수 있습니다.</p>\n<h2 id=\"4-socketio란\"><a href=\"#4-socketio%EB%9E%80\" aria-label=\"4 socketio란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. SocketIO란?</h2>\n<p>SocketIO는 Guillermo Rauch가 만들어 WebSocket, XHR-Polling, Flash-Socket, IFrame, JSONP Polling 등을 통합하여 브라우저에 맞게 사용할 수 있는 Framework((Realtime application framework)입니다. SocketIO는 웹 서버의 종류와 브라우저 버전을 파악하여 가장 적합한 기술을 사용하여 WebSocket을 이용할 수 있게 만들어줍니다. 예를 들어, IE9 버전에서 SocketIO로 구현된 서비스를 이용하면, 이는 XHR-Polling을 이용하여 이를 구현해줄 것입니다.</p>\n<p>간단히 SocketIO의 특징을 정리해보겠습니다.</p>\n<h5 id=\"1-reliability\"><a href=\"#1-reliability\" aria-label=\"1 reliability permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Reliability</h5>\n<ul>\n<li>Proxy 및 Load Balancers 환경에서도 사용할 수 있습니다.</li>\n<li>Personal Firewall 및 Antivirus software 환경에서도 사용할 수 있습니다.</li>\n</ul>\n<h5 id=\"2-auto-reconnection-support\"><a href=\"#2-auto-reconnection-support\" aria-label=\"2 auto reconnection support permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Auto-reconnection support</h5>\n<ul>\n<li>달리 지시되지 않는 한 연결이 끊어진 클라이언트는 서버를 다시 사용할 수있을 때까지 지속해서 다시 연결을 시도합니다.</li>\n</ul>\n<h5 id=\"3-disconnection-detection\"><a href=\"#3-disconnection-detection\" aria-label=\"3 disconnection detection permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Disconnection detection</h5>\n<ul>\n<li>heartbeat 메커니즘은 <a href=\"https://github.com/socketio/engine.io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Engine.IO</a> 수준에서 구현되므로 서버와 클라이언트가 더 이상 응답하지 않는 경우를 알 수 있습니다.</li>\n<li>이 기능은 서버와 클라이언트 모두에서 설정된 타이머를 사용하여 수행되며 시간 초과 값(pingInterval 및 pingTimeout 매개 변수)은 연결 핸드 셰이크 중에 공유됩니다. 이러한 타이머를 사용하면 후속 클라이언트 호출을 동일한 서버로 보내야하므로 배수 노드를 사용할 때 고정 세션 요구 사항이 필요합니다.</li>\n</ul>\n<h5 id=\"4-binary-support\"><a href=\"#4-binary-support\" aria-label=\"4 binary support permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Binary support</h5>\n<p>아래 사항을 이용화여 Serializable 가능 데이터 구조가 생성 될 수 있습니다.</p>\n<ul>\n<li>브라우저의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Javascript/Reference/Global_Objects/ArrayBuffer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ArrayBuffer</a> 및 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Blob</a></li>\n<li>Node.js의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Javascript/Reference/Global_Objects/ArrayBuffer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ArrayBuffer</a> 및 <a href=\"https://nodejs.org/api/buffer.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Buffer</a></li>\n</ul>\n<h2 id=\"outro\"><a href=\"#outro\" aria-label=\"outro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Outro</h2>\n<p>WebSocket은 한줄로 요약하면 <code class=\"language-text\">Web이라는 요청과 응답이라는 제약적인 환경에 벗어나, Socket을 통한 지속적인 통신을 가능만드는 것</code>이라고 표현할 수 있습니다. HTTP를 이용하는 웹의 환경을 고려하여 WebSocket을 바라본다면 WebSocket에 대해 더 많은 사고를 할 수 있을 것이라고 생각합니다.</p>\n<p>WebSocket을 이용하는 간단한 서비스는 칸반 서비스를 지원하는 Trello입니다. Trello의 칸반이 변경된 것을 접속한 유저는 실시간으로 확인할 수 있습니다. 이러한 이벤트를 처리하기 위해 Trello는 SocketIO를 이용합니다. 즉, WebSocket을 지원하는 브라우저와는 WebSocket을 이용하여 이벤트를 처리한다는 것을 의미합니다. 이처럼 많은 프로덕트 서비스가 WebSocket을 이용하고 있습니다.</p>\n<p>WebSocket을 실무적으로 쓰기 위해서는 보안 및 여러가지 세션관련한 부분에 대한 이해가 필요합니다. 저 또한 Spring의 Security와 같이 이용하여 이부분을 큰 어려움 없이 해결할 수 있었지만, 그렇지 않은 환경에서는 이를 어떻게 다뤄야 할지에 대한 깊은 고민과 학습이 필요할 것으로 보입니다. <a href=\"https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/websocket.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Spring Websocket</a>을 보면 여러가지 사항에 대해 스프링 개발자들이 고민한 정보를 확인할 수 있습니다. 이러한 간접적인 API를 확인하여 어떠한 것들이 필요한지를 더 확인하고 접근하면 좋을 것으로 판단합니다.</p>\n<p>이상 부족하지만, WebSocket 관련한 글을 마치겠습니다. 다음에는 WebSocket을 이용한 간단한 웹 서비스를 개발하여 코드와 함께 블로그를 작성해보겠습니다. 감사합니다.</p>\n<ul>\n<li>PS : <a href=\"https://socket.io/get-started/chat/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Simple Example using SocketIO</a>를 참고하시면 NodeJS Express와 SocketIO를 이용하여 간단한 WebSocket을 체험할 수 있습니다.</li>\n</ul>\n<h2 id=\"4-references\"><a href=\"#4-references\" aria-label=\"4 references permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. References</h2>\n<ul>\n<li><a href=\"http://d2.naver.com/helloworld/1336\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Naver D2 - Websocket - SocketIO</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/WebSockets/Writing_WebSocket_servers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mozilla - Websocket</a></li>\n<li><a href=\"https://socket.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SocketIO</a></li>\n</ul>","id":"1cf1d915-a1ea-5113-800b-9c41ee2160a1","fields":{"slug":"network-socket-web-socket이란-무엇인가-어떻게-사용하는가"},"frontmatter":{"title":"[Network/Socket] WebSocket이란 무엇인가? 어떻게 사용하는가?","date":"2018-04-12T00:00:00.000Z","author":"Seolhun","subTitle":"","banner":"/assets/covers/websocket.png","category":"WebSocket","tags":["Network","Socket","WebSocket","SocketIO"]},"timeToRead":7}],"tagsName":"Network"}}}