{"componentChunkName":"component---src-templates-category-tsx","path":"/categories/network","webpackCompilationHash":"7cbb981b32ff4104a128","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"posts":[{"excerpt":"HTTP의 관심을 갖고 책을 읽으면서 학습을 하고 있지만, Network에 더 근본적인 IP와 UDP, TCP에 대해서 이해해야 할 필요가 있다고 생각하여 적게되었습니다. 관련 사항에 간단하게 읽어본적은 있지만 읽어보는 것과 이를 숙지하기 위해 반복적으로 학습하는 것은 큰차이가 있기에 이번 시간을 계기로 이와 관련한 내용을 숙지하고자 합니다. IP란? IP에서 인터넷(the Internet) 이름자체가 'inter…","html":"<p>HTTP의 관심을 갖고 책을 읽으면서 학습을 하고 있지만, Network에 더 근본적인 IP와 UDP, TCP에 대해서 이해해야 할 필요가 있다고 생각하여 적게되었습니다. 관련 사항에 간단하게 읽어본적은 있지만 읽어보는 것과 이를 숙지하기 위해 반복적으로 학습하는 것은 큰차이가 있기에 이번 시간을 계기로 이와 관련한 내용을 숙지하고자 합니다.</p>\n<h2 id=\"ip란\"><a href=\"#ip%EB%9E%80\" aria-label=\"ip란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IP란?</h2>\n<p>IP에서 인터넷(the Internet) 이름자체가 'inter-' 라는 접두사와 '네트워크'를 의미하는 'net'이 합쳐진 말로, 인터넷은 네트워크들을 연동하는 것이라고 말할 수 있습니다. 즉, IP(Internet Protocol)라는 이름은 <code class=\"language-text\">네트워크를 연동하는 프로토콜</code>이라는 뜻으로 해석하면 쉬울 것 같습니다. IP는 OSI의 3 Layer(Network Layer)와 Internet Protocol Suite의 3 Layer(Internet Layer)에 위치하고 있습니다.</p>\n<p>IP라는 이름처럼 어디에서든 간단하게 IP만 올릴 수 있으면 어떤 네트워크든 연결할 수 있습니다. 그래서, IP는 아래 그림처럼 모래 시계의 허리에 비유하여 설명할 수 있습니다. 그림처럼 IP 아래로는 네트워크를 만들 수 있는 다양한 하드웨어 기술 (Ethernet, WiFi 등...) 이 존재하고 있고, IP 위로는 다양한 응용 서비스(HTTP, FTP 등...)들이 동작할 수 있습니다. 간단한 예로 컴퓨터에 연결하는 랜선은 Ethernet, 모바일로 무선 네트워크를 이용하는 것은 WiFI, 개발 간 API를 호출할 때는 HTTP를 이영할 수 있는 것입니다. 이처럼 IP를 기반으로하면 어떠한 디바이스와 서버, 혹은 사용자가 사용해도 TCP/UDP와 관련된 네트워크 기능들을 큰 어려움없이 사용할 수 있습니다.</p>\n<div class='text-center'>\n  <img src=\"/assets/images/contents/20180426/network/ip.png\" width=\"100%\">\n</div>\n<p>IP의 특징은 연결을 보장하기 위한 노력은 하지만 100% 보장해주지 않습니다. 이를 <code class=\"language-text\">Best-effort</code>라고 표현하는데, IP 가 best-effort가 될 수 밖에 없는 이유는 서로 다른 특성의 여러 네트워크를 연동해야 되기 때문입니다.</p>\n<h2 id=\"udp란\"><a href=\"#udp%EB%9E%80\" aria-label=\"udp란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UDP란?</h2>\n<p>UDP(User Datagram Protocol)는 컴퓨터가 다른 컴퓨터와 데이터 통신을 하기 위한 프로토콜의 일종입니다. UDP는 세계 통신표준으로 개발된 OSI 모형에서 4번째 계층인 전송 계층(Transport Layer)에서 사용하는 프로토콜입니다. 동일 계층(OSI 4계층)에서 사용하는 또다른 프로토콜로 TCP가 존재합니다.</p>\n<p>UDP에 설명하기 앞서 같은 계층에 있는 TCP를 설명하면 좋을 것 같습니다. UDP와 같은 계층에 있는 TCP는 데이터 신뢰성을 보장하기 위한 방식이기 때문에 누락된 데이터를 모두 받기위한 메커니즘이 정의되어 있습니다. 그러므로, 이메일이나 파일전송과 같은 100% 데이터의 보장이 필요한 분야에서 필수요소로 사용되고 있습니다. 하지만, 실시간 스트리밍 서비스에서 TCP는 걸림돌로 작용됩니다. TCP는 전체 영상에서 점 하나 못받은 것 때문에 버퍼링으로 재생이 중지되며, 혼잡제어를 위해 보내는 양도 조절하기 때문에 영상 데이터의 퀄리티가 오락가락하는 문제를 발생시킵니다. 결국 이를 해결하기 위하여 제시된 것이 UDP를 사용하는 방법입니다.</p>\n<p><code class=\"language-text\">UDP의 특징은 간단하게 TCP의 모든 신뢰성 매커니즘이 기능이 없다고 보면됩니다.</code> 그냥 상대와 접속했고, 전송속도를 48Kbps로 설정했으면 무조건 48Kbps로 데이터를 일방적으로 전송하기만 합니다. 받는 쪽에서 데이터를 제대로 받고 있는지는 신경을 쓰지 않습니다. 그렇기 때문에 UDP로 데이터를 제공할 경우 32Kbps, 48Kbps, 64Kbps와 같은 일방적인 속도를 선택할 수 있는 옵션만을 제공합니다.</p>\n<p>하지만, 신뢰성이 보장되지 않기 때문에 UDP로 데이터를 보내면 손실되는 데이터가 발생합니다. 그렇기에 동영상의 경우 데이터가 많이 소실되었다면 이상한 화면이 나올 수도 있지만, 데이터 몇 개 소실로는 전체 화면에서 점 몇 개가 제대로 안나오는 수준에 불과하게 됩니다. 그렇기에 사람들이 크게 불평하지 않을 수준의 영상만 제공할 필요가 있다면 TCP를 쓸 이유가 없습니다. 그렇기에 실시간 스트리밍을 하는 곳에서 주로 사용합니다.</p>\n<p>이로 인해 UDP Header를 확인해보면 목적지 주소, 데이터 순서, checksum과 실데이터만 포함되고, 확인응답 같은 것이 없습니다. 그래서, TCP보다 용량이 가볍고 송신속도가 빠르게 작동됩니다. 하지만 확인응답을 하지 못하기때문에 신뢰도가 TCP보다 떨어지게 됩니다. 따라서 <code class=\"language-text\">UDP는 비연결형이라 부르며 TCP는 연결형이라 구분합니다.</code></p>\n<div class='text-center'>\n  <img src=\"/assets/images/contents/20180426/network/udp-header.png\" width=\"100%\">\n</div>\n<h2 id=\"tcp란\"><a href=\"#tcp%EB%9E%80\" aria-label=\"tcp란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP란?</h2>\n<p>TCP(Transmission Control Protocol)의 축약어로 컴퓨터가 다른 컴퓨터와 데이터 통신을 하기 위한 프로토콜의 일종입니다. TCP는 세계 통신표준으로 개발된 OSI 모형에서 4번째 계층인 전송계층(Transport Layer)에서 사용하는 프로토콜로, 보통 하위 계층(Network Layer)에서 사용되는 IP와 엮어서 TCP/IP로 표현합니다.</p>\n<p>TCP가 개발된 배경은 군사적인 목적으로 어느 환경에서도 정상적으로 동작되는 네트워크 개발하기 위함이었습니다. 이를 위해 사용된 것이 패킷교환(Packet Switching) 방식으로 목적지가 정해져있지만 해당 목적지까지의 경로는 정해져 있지 않습니다. 따라서 서로 연결이 가능한 회선 하나만 남아있어도 통신이 끊어지지 않고 계속될 수 있는 통신환경을 구축하였습니다. 다만 이 방식은 어떻게든 통신을 유지하는 것이 목적이므로 네트워크 환경의 안정성은 떨어질 수 밖에 없습니다. 이로 인해 중간에 데이터가 유실되거나 너무 늦게 전달되는 등 신뢰성이 떨어지는 문제가 있었는데, 이러한 문제점들을 해결하고자 신뢰성을 보장할 수 있는 통신 프로토콜을 연구하게 됐고, 이에 따라 나온 것이 TCP입니다.</p>\n<h2 id=\"tcp-신뢰성-보장과-흐름-제어flow-control\"><a href=\"#tcp-%EC%8B%A0%EB%A2%B0%EC%84%B1-%EB%B3%B4%EC%9E%A5%EA%B3%BC-%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4flow-control\" aria-label=\"tcp 신뢰성 보장과 흐름 제어flow control permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP, 신뢰성 보장과 흐름 제어(Flow Control)</h2>\n<p>신뢰성 보장을 알아보기 위해서는 TCP의 Header 정보를 보면 도움이 될것 같습니다. TCP header에는 목적지 주소, 확인응답, 오류 검출 및 복원, 실제 데이터 등이 포함됩니다. 그 중 UDP와 구분되는 부분이 바로 <code class=\"language-text\">확인응답(Acknowledge)</code>입니다. 즉, TCP는 신뢰성을 보장하기 위해 ACK을 기반으로 재전송과 타임아웃 방법을 이용하고 있습니다.</p>\n<div class='text-center'>\n  <img src=\"/assets/images/contents/20180426/network/tcp-header.png\" width=\"100%\">\n</div>\n<p>TCP의 데이터는 물줄기처럼 흐른다고 해서 stream이라는 표현을 사용하는데, 이는 결국 패킷(Packet)을 의미합니다. TCP의 패킷이 전송되어 이에 응답할 때마다 ACK이라는 별도의 패킷을 생성하여 다음 필요한 패킷에 대해 알려주며 응답합니다. 만약, ACK 이 일정 시간 동안 오지 않으면 전송자는 패킷을 다시 보냅니다. 다시 보내는 경우는 크게 2가지 입니다.</p>\n<ol>\n<li>전송되는 패킷이 목적지까지 제대로 전송되지 않은 경우</li>\n<li>ACK가 전송자에게 제대로 전송되지 않은 경우</li>\n</ol>\n<p>하지만, 위 두 상황을 확실히 구분하는 것이 어렵기 때문에 일정기간 동안 응답을 받지 못하면 무조건 패킷을 다시 전송합니다.</p>\n<div class='text-center'>\n  <img src=\"/assets/images/contents/20180426/network/tcp.jpg\" width=\"100%\">\n</div>\n<p>만약, 다시 보냈음에도 불구하고 일정시간을 초과하여 응답받지 못하면 이를 전송자에게 알려주고 종료합니다(타임아웃).</p>\n<h2 id=\"tcp-신뢰성을-위한-ack-2가지-방법\"><a href=\"#tcp-%EC%8B%A0%EB%A2%B0%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-ack-2%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95\" aria-label=\"tcp 신뢰성을 위한 ack 2가지 방법 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP, 신뢰성을 위한 ACK 2가지 방법</h2>\n<p>물론 TCP가 이렇게 패킷을 하나씩만 전송하지는 않습니다. <code class=\"language-text\">Sliding window</code>라는 개념(창문을 조금 열고 많이 열고 하는 것처럼 양을 조절한다는 뜻에서 Sliding window입니다.)을 이용해서 보낼 수 있는 만큼을 연속으로 계속 전송합니다. 하지만 이처럼 ACK을 받지 않고 연속으로 전송하는 것은 제한이 있습니다. 그리고, ACK을 못 받는 순간이오면 TCP는 더는 아무것도 전송하지 않고 재전송이 결정될 때까지 대기합니다.</p>\n<p>그런데, 한 번에 하나씩 전송하고 응답받는 것이 아니라 여러 개를 연속으로 전송한다면, 가운데 패킷이 유실된 경우는 어떻게 될까요? TCP의 기본 동작은 뭔가 유실되면 그 뒤에 아무리 정상적으로 전송되었어도 전부 버리고 유실된 것부터 재전송합니다. 하지만, 이건 상당히 비효율적입니다. 이 문제를 해결하기 위해 등장하게 되는 방법이 바로 <code class=\"language-text\">cumulative ACK</code>와 <code class=\"language-text\">selective ACK</code>입니다.</p>\n<p>Cumulative ACK은 한 번에 여러 개 패킷을 전송하더라도 문제가 되는 ACK 하나만 기억하면 됩니다. 반면 selective ACK은 여러개 패킷에 대해서 어떤 ACK를 응답받았는지에 대해 모두 기억해야 합니다. 다시 말해 cumulative ACK은 기억해야 되는 것이 적고 구현도 간단한 반면, selective ACK은 기억해야되는 것이 많고 구현도 복잡합니다. 이는 효율성과 복잡성에 대한 전형적인 트레이드 오프라고 할 수 있습니다.</p>\n<p>초기의 TCP 는 cumulative ACK 을 기반으로 했으나, 응답받지 못한 것을 기준으로 전송된 뒤에 것을 전부 버리다보니 비효율적입니다. 그 때문에 나중에는 selective ACK 을 TCP의 옵션으로 채택했습니다.</p>\n<h2 id=\"tcp-혼잡-제어congestion-control\"><a href=\"#tcp-%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4congestion-control\" aria-label=\"tcp 혼잡 제어congestion control permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP, 혼잡 제어(Congestion Control)</h2>\n<p>사실 초기 TCP는 혼잡제어라는 요소가 없었습니다. 위에서 언급했듯이 초기 TCP는 cumulactive ACK와 selective ACK를 사용하면서 한정된 네트워크 대역폭에서 소수의 사람들이 쓸 때는 문제가 없었습니다. 하지만, 1986년 사용자가 점점 늘어나면서 네트워크 회선이 부하를 감당하지 못하는 문제가 발생하였습니다. 이를 해결하기 위해 등장하게 된 요소가 바로 혼잡 제어입니다.</p>\n<p>단순한 예로 통신을 시작할 때 일단 보내는 쪽에서 30 ~ 35쪽까지 자료를 보내서 상대가 잘 받았으면 이후 보내는 양을 조금씩 늘려보는 방식을 취합니다. 그러다가, 상대가 데이터를 제대로 받지 못한 것이 확인되면 그 즉시 보내는 양을 확 줄입니다. 그리고 다시 조금씩 보내는 양을 늘렸다가 또 못 받으면 줄여버리는 형태로 보내는 양을 조절합니다. 보내는 양을 늘리고 줄이는 방법은 AIMD(Addictive Increase/Multicative Decrease)를 채택하고 있으나 더 자세한 내용은 <a href=\"https://ko.wikipedia.org/wiki/TCP_%ED%98%BC%EC%9E%A1_%EB%B0%A9%EC%A7%80_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TCP 혼잡 방지 알고리즘</a>을 확인하면 큰 도움이 될 것입니다.</p>\n<p>그리고 이때부터 패킷이 유실되면 TCP를 전송하는 쪽에서 얼른 양을 줄이는 혼잡 제어 요소가 추가되었습니다.</p>\n<h2 id=\"tcpudp의-포트-목록\"><a href=\"#tcpudp%EC%9D%98-%ED%8F%AC%ED%8A%B8-%EB%AA%A9%EB%A1%9D\" aria-label=\"tcpudp의 포트 목록 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP/UDP의 포트 목록</h2>\n<p>일반적으로 포트 번호는 다음과 같이 세 가지로 나눌 수 있습니다.</p>\n<ul>\n<li>\n<p>0번 ~ 1023번: 잘 알려진 포트 (well-known port)</p>\n<ul>\n<li>잘 알려진 포트(well-known port)는 특정한 쓰임새를 위해서 IANA에서 할당한 TCP 및 UDP 포트 번호의 일부입니다.</li>\n</ul>\n</li>\n<li>1024번 ~ 49151번: 등록된 포트 (registered port)</li>\n<li>49152번 ~ 65535번: 동적 포트 (dynamic port)</li>\n</ul>\n<p><code class=\"language-text\">대부분의 유닉스 계열 운영 체제의 경우, 잘 알려진 포트를 열려면 루트 권한이 있어야 한다.</code> 이 번호는 강제적으로 지정된 것은 아니며, IANA의 권고안입니다. 가끔 각 포트 번호를 그대로 사용하지 않고 다른 용도로 사용하기도 합니다.</p>\n<p>자세한 Port 정보를 확인하시고 싶으시면 <a href=\"https://ko.wikipedia.org/wiki/TCP/UDP%EC%9D%98_%ED%8F%AC%ED%8A%B8_%EB%AA%A9%EB%A1%9D\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TCP/UDP의<em>포트</em>목록</a>를 참조해주세요.</p>\n<h2 id=\"개인적으로-추천하는-체크사항\"><a href=\"#%EA%B0%9C%EC%9D%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B6%94%EC%B2%9C%ED%95%98%EB%8A%94-%EC%B2%B4%ED%81%AC%EC%82%AC%ED%95%AD\" aria-label=\"개인적으로 추천하는 체크사항 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개인적으로 추천하는 체크사항</h2>\n<ul>\n<li>Youtube는 TCP인가 UDP인가?</li>\n<li>WebRTC는 TCP인가 UDP인가?</li>\n</ul>\n<h2 id=\"outro\"><a href=\"#outro\" aria-label=\"outro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Outro</h2>\n<p>HTTP를 이용하면서 기반이되는 IP와 TCP, UDP에 대해 알아보는 유익한 시간을 가졌습니다. 먼저, <a href=\"http://www.inven.co.kr/webzine/news/?news=165870\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">문대경 - 아이펀팩토리 대표: 인벤 - TCP/UDP 차이</a>라는 글에 대해 너무 감사하다는 말씀드리고 싶습니다. 해당 글과 WiKi를 중점으로 개념을 학습하고 하나하나 읽고 수정하면서 네트워크 기본 개념에 대해 숙지할 수 있는 좋은 기회가 되었습니다.</p>\n<p>어떻게 보면 이미 좋은 글들인데, 이러한 노력이 필요한가라고 생각할 수 있습니다. 하지만, 개인적으로 이렇게 몇 시간 동안 내용을 읽고 수정하면 간단하게 검색한 글을 읽는것 보다 훨씬 내용에 대한 이해와 숙지가 빨라진다고 생각합니다. 특히, 이번 TCP 관련 역사와 UDP와의 차이, TCP Header, Acknowledge 등에 대한 개념을 인지할 수 있었습니다. 관련 내용을 기반으로 HTTP에 대한 시각과 HTTP의 한계점 그리고, 관련된 정보를 더욱 더 알아볼 수 있는 기회를 가지게 되었습니다. 다음에는 TCP/IP/HTTP 등과 연관된 내용도 정리해보겠습니다.</p>\n<p>이상 부족한 글을 마치겠습니다. 감사합니다.</p>\n<h2 id=\"references\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<ul>\n<li><a href=\"https://namu.wiki/w/IP\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Namu WiKi - IP란</a></li>\n<li><a href=\"https://namu.wiki/w/UDP\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Namu WiKi - UDP란</a></li>\n<li><a href=\"http://www.inven.co.kr/webzine/news/?news=165870\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TCP, 그리고 UDP 쉽게 알아보는 두 개념과 차이점</a></li>\n<li><a href=\"https://www.lifewire.com/tcp-headers-and-udp-headers-explained-817970\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TCP Headers and UDP Headers Explained</a></li>\n<li><a href=\"https://ciscoskills.net/2011/03/28/understanding-udp/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Understanding UDP</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/TCP_%ED%98%BC%EC%9E%A1_%EB%B0%A9%EC%A7%80_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WiKi - TCP 혼잡방지 알고리즘</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/TCP/UDP%EC%9D%98_%ED%8F%AC%ED%8A%B8_%EB%AA%A9%EB%A1%9D\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TCP/UDP의<em>포트</em>목록</a></li>\n</ul>","id":"cfd9b89b-bf61-5f7a-9f48-46b8773f3f7e","fields":{"slug":"network-ip-udp-tcp란-무엇인가"},"frontmatter":{"title":"[Network] IP, UDP, TCP란 무엇인가?","date":"2018-06-02T00:00:00.000Z","author":"Seolhun","subTitle":"HTTP 이해를 위한 기본 네트워크 지식, IP, UDP, TCP","banner":"/assets/covers/network.png","category":"Network","tags":null},"timeToRead":7},{"excerpt":"이번에는 Http와 Https에 대한 정의와 간단한 차이점에 대해서 정리해보고자 합니다. Intro Let's Encrypt를 사용하여 개인 Domain에 Https를 적용한 적이 있습니다.…","html":"<p>이번에는 Http와 Https에 대한 정의와 간단한 차이점에 대해서 정리해보고자 합니다.</p>\n<h2 id=\"intro\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p><a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Let's Encrypt</a>를 사용하여 개인 Domain에 Https를 적용한 적이 있습니다. 3개월 동안 무료로 사용할 수 있으며 이후에 수동으로 다시 갱신해야 합니다. 간단한 로직과 함게 크론을 사용하면 갱신도 자동적으로 하여 사용할 수 있습니다. 무료로서 개인 도메인으로 사용하기에는 적합하지만, 엔터프라이즈에서 사용하기에는 보안수준이 낮아 비용을 지불해서라도 더 좋은 서비스를 이용해야 할 것입니다.</p>\n<p>이와 더불어 함게 사용되는 툴이 <a href=\"https://www.wireshark.org/download.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Wireshark</a>입니다. 해당 도메인에서 발생되는 패킷을 확인할 수 있으며, 필터링을 통해 원하는 것만을 필터링 할수도 있습니다.</p>\n<p>이렇게 2가지를 언급하는 이유는 https는 즉, 네트워크에서 전송되는 패킷을 암호화하여 이를 쉽게 해독할 수 없도록 만들어줍니다. http에서 해당 패킷을 확인해보고, https 적용 후 패킷을 다시 확인해보면 그 차이를 크게 확인 할 수 있습니다.</p>\n<img src=\"/assets/images/contents/20180420/http/http.png\" width=\"100%\">\n<h2 id=\"httphypertext-transfer-protocol\"><a href=\"#httphypertext-transfer-protocol\" aria-label=\"httphypertext transfer protocol permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP(HyperText Transfer Protocol)</h2>\n<p><code class=\"language-text\">HTTP(HyperText Transfer Protocol)</code>는 WWW 상에서 정보를 주고받을 수 있는 프로토콜입니다. 주로 HTML 문서를 주고받는 데에 쓰입니다. TCP와 UDP를 사용하며, 기본 TCP/IP 포트는 80 포트를 사용합니다. 1996년에 첫 상용화버전인 HTTP/1.0가 발표되었고, 1999년에 HTTP/1.1, 그리고 2015년 HTTP/2를 공식으로 발표하였습니다.</p>\n<p>HTTP에 대해 더 간단히 설명하자면, HTTP는 요청(Request)와 응답(Response)로 구성되어 있고, 클라이언트가 요청을 하면 서버가 응답을 하는 구조로 되어 있습니다. <code class=\"language-text\">HTTP는 FTP나 텔넷과는 다르게 비연결식입니다.</code> FTP나 Telnet은 클라이언트가 서버에 정보를 요청해도 서버가 클라이언트와 연결을 끊지 않지만, <code class=\"language-text\">HTTP는 클라이언트가 서버에 정보를 요청하면 응답 코드와 내용을 전송하고 클라이언트와 연결을 종료합니다.</code> 즉, 요청과 응답이 하나의 연결로 이어지지 않고 요청에 따른 응답에으로 2가지 작업으로 진행됩니다.</p>\n<p>이러한 HTTP 특징으로 HTTPS를 들어가기 전에 알 필요가 있는 <code class=\"language-text\">Packet</code>에 대해서 알아보겠습니다.</p>\n<h2 id=\"packet\"><a href=\"#packet\" aria-label=\"packet permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Packet</h2>\n<p>Packet이란?, Package(화물)와 Bucket(덩어리)의 합성어입니다. 즉, WWW Web에서는 전송될 때, 서로 교환되는 실제의 내용물로 분할된 파일 데이터에 주소와 에러 데이터 등이 기록됩니다. '분할'의 특성 때문에 자연스럽게 시분할(Time-slice) 방식으로 처리가 가능한 특징을 가지고 있어, 선이 끊기면 연결성이 끊어지는 서킷 방식과는 다르게 양측 단말의 길만 정해지면 언제든지 우회가 가능하다는 장점이 있습니다. 또한, 중간에 분실한 패킷에 대해서는 그 부분만 다시 보내면 문제되지 않기 때문에 인터넷은 물론 허브 역시 패킷 방식을 사용합니다. 다만, 이러한 작업을 위해 패킷에 고유의 번호를 매겨야 하고, 이 순서를 양측이 동일하게 사용해야 한다는 단점이 있습니다.</p>\n<p>이러한 문제를 해결하기 위해 제약사항 등을 포함한 통신 규칙, 즉 프로토콜이 등장한 것입니다. TCP/IP 등 신뢰성 기반의 프로토콜(HTTP 등)은 대부분 이러한 기능을 지니고 있습니다. <strong>간단히 말해, '택배에 송장 번호를 매긴다' 생각하면 편하게 이해할 수 있습니다.</strong></p>\n<h2 id=\"httpshypertext-transfer-protocol-security---over-tls-ssl-http-secure\"><a href=\"#httpshypertext-transfer-protocol-security---over-tls-ssl-http-secure\" aria-label=\"httpshypertext transfer protocol security   over tls ssl http secure permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS(HyperText Transfer Protocol Security - over TLS, SSL, HTTP Secure)</h2>\n<p><code class=\"language-text\">HTTPS(Hypertext Transfer Protocol over Secure Socket Layer)</code>는 월드 와이드 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전입니다. HTTPS는 통신의 인증과 암호화를 위해 넷스케이프 커뮤니케이션즈 코퍼레이션이 개발했습니다. HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화합니다. 따라서 데이터의 적절한 보호를 보장합니다. HTTPS의 기본 TCP/IP 포트는 443을 이용합니다. HTTPS의 보안수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려다고 할 수 있습니다.</p>\n<p>위에서 간단히 언급했듯이, HTTPS는 패킷이 암호화되어 있기 때문에 패킷캡쳐(WireShark와 같은) 프로그램으로 사용해서 패킷의 내용을 보더라도 암호화된 내용만 보이게 됩니다. 암호화는 TLS라고 하여 OSI7계층에서 L4의 전송계층(Transport)에서 이루어지게 됩니다. 이러한 암호화 과정을 거치기 때문에 HTTPS는 HTTP보다 느리지만, 현재 인터넷 속도에서 이는 큰 의미가 없습니다. 그리고 HTTPS는 개인정보가 거래되는 웹 상에서는 의무화되어있습니다.</p>\n<h2 id=\"sslsecure-sockets-layer\"><a href=\"#sslsecure-sockets-layer\" aria-label=\"sslsecure sockets layer permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL(Secure Sockets Layer)</h2>\n<p>SSL은 Secure Sockets Layer를 의미하며 이는 웹 브라우저와 엡 서버 사이에 암호화된 통신을 구현하는 글로벌 표준 보안 기술입니다. 요약하자면, <code class=\"language-text\">SSL은 두 의도된 당사자들만의 사적인 &quot;대화&quot;를 가능하게 해 줍니다.</code> 이 보안 연결을 설정하기 위해, SSL 인증서(디지털 인증서라 하기도 함)가 웹 서버에 설치되어 다음 두 가지 기능을 수행합니다.</p>\n<ol>\n<li>웹사이트의 신원을 인증(방문자에게 해당 사이트가 위조 사이트가 아님을 보장)</li>\n<li>전송되는 데이터를 암호화</li>\n</ol>\n<h2 id=\"tlstransport-layer-security\"><a href=\"#tlstransport-layer-security\" aria-label=\"tlstransport layer security permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLS(Transport Layer Security)</h2>\n<p>인터넷을 사용한 통신에서 보안을 확보하려면 두 통신 당사자가 서로가 신뢰할 수 있는 자임을 확인할 수 있어야 하며, 서로간의 통신 내용이 제3자에 의해 도청되는 것을 방지해야 합니다. 따라서 <code class=\"language-text\">서로 자신을 신뢰할 수 있음을 알리기 위해 전자 서명이 포함된 인증서를 사용하며, 도청을 방지하기 위해 통신 내용을 암호화</code>합니다. 이러한 통신 규약을 묶어 정리한 것이 바로 TLS이며, 주요 웹브라우저 주소창에 자물쇠 아이콘이 뜨는 것으로 TLS의 적용 여부를 확인할 수 있습니다.</p>\n<p>간단한 예를 들어, 인터넷 뱅킹을 하기 위해 은행의 사이트에 방문했을 때, 고객은 그 사이트가 정말 은행의 사이트가 맞는지 아니면 해커가 만든 가짜 피싱 사이트인지 확인할 수 있어야 하며, 은행 역시 자신의 서비스에 접속한자가 해당 고객이 맞는지 아니면 고객의 컴퓨터와 서버 사이에서 내용을 가로채고자 하는 해커인지 확인할 수 있어야 합니다. 그리고 은행과 고객 간의 통신 내용이 다른 해커에게 도청되지 않도록 내용을 숨겨야 합니다. 이럴 때 바로 은행과 고객 간에 TLS를 사용한 연결을 맺어 안전하게 통신을 할 수 있습니다.</p>\n<h2 id=\"tls-handshaking\"><a href=\"#tls-handshaking\" aria-label=\"tls handshaking permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLS HandShaking</h2>\n<ol>\n<li>먼저, 클라이언트에서 서버에 ClientHello 메시지를 보낸다. 여기에는 클라이언트에서 가능한 TLS 버전, 세션 식별자, 암호 설정 등의 정보가 포함된다.</li>\n<li>클라이언트의 메시지를 받은 서버는 ServerHello 메시지를 클라이언트에게 보낸다. 여기에는 ClientHello 메시지의 정보 중 서버에서 사용하기로 선택한 TLS 버전, 세션 식별자, 암호 설정 등의 정보가 포함된다.</li>\n<li>서버가 클라이언트에 Certificate 메시지를 보낸다. 여기에는 서버의 인증서가 들어간다. 이 인증서는 별도의 인증 기관에서 발급받은 것이며, 서버가 신뢰할 수 있는 자임을 인증한다. 전송이 끝나면 ServerHelloDone 메시지를 보내 끝났음을 알린다.</li>\n<li>클라이언트는 서버에서 받은 인증서를 검증한다. 인증서의 유효 기간이 만료되지 않았는지, 그 인증서가 해당 서버에게 발급된 인증서가 맞는지 등을 확인한다. 인증서를 신뢰할 수 있다고 판단하였다면 다음 단계로 넘어간다.</li>\n<li>클라이언트는 임의의 pre-master secret을 생성한 뒤, 서버가 보낸 인증서에 포함된 공개 키를 사용해 암호화한다. 이렇게 암호화된 pre-master secret을 ClientKeyExchange 메시지에 포함시켜 서버에 전송한다.</li>\n<li>서버는 전송받은 정보를 복호화하여 pre-master secret을 알아낸 뒤, 이 정보를 사용해 master secret을 생성한다. 그 뒤 master secret에서 세션 키를 생성해내며, 이 세션 키는 앞으로 서버와 클라이언트 간의 통신을 암호화하는데 사용할 것이다. 물론 클라이언트 역시 자신이 만들어낸 pre-master secret을 알고 있으므로, 같은 과정을 거쳐 세션 키를 스스로 만들 수 있다.</li>\n<li>이제 서버와 클라이언트는 각자 동일한 세션 키를 가지고 있으며, 이를 사용해 대칭 키 암호를 사용하는 통신을 할 수 있다. 따라서 우선 서로에게 ChangeCipherSpec 메시지를 보내 앞으로의 모든 통신 내용은 세션 키를 사용해 암호화해 보낼 것을 알려준 뒤, Finished 메시지를 보내 각자의 핸드셰이킹 과정이 끝났음을 알린다.</li>\n<li>이제 서버와 클라이언트 간에 보안 통신이 구성된다.</li>\n</ol>\n<p>쉽게 요약해서, 먼저 서로가 어떤 TLS 버전을 사용 가능한지를 확인하고, 인증서를 사용해 서로를 믿을 수 있는지 확인한 뒤, 서로간의 통신에 쓸 암호를 교환하는 것입니다.</p>\n<h2 id=\"outro\"><a href=\"#outro\" aria-label=\"outro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Outro</h2>\n<p>HTTP의 특징처럼 전송/응답의 환경에서 Packet을 통해 해당 데이터를 전송받고 응답할 수 있습니다. 즉, HTTPS는 이러한 HTTP 환경에 전송/응답되는 데이터를 암호화하는 처리를 추가적으로 해주는 것입니다. 이 외에도 신뢰성 있는 3자를 통해 클라이언트와 서버 간의 신뢰성을 확보할 수 있도록 도와주는 인증과정을 확인할 수 있습니다. 이 외에도 HTTP를 통해 전송되는 Packet과 암호화 과정의 방법인 TLS, SSL 등에 대해서 알아볼 수 있었습니다. 부족한 내용도 많지만, 간단하게 알아봄으로써 그 둘의 차이를 알 수 있었다고 생각합니다.</p>\n<p>제가 생각하는 HTTP와 HTTPS의 가장 큰 차이는 즉, <code class=\"language-text\">HTTP의 전송/응답 데이터를 암호화 하는 것</code>이라고 생각합니다. TLS는 OSI 7계층 중 L4 Transport 게층에서, SSL은 응용계층과 전송계층 사이에 독립적인 프로토콜 계층을 만들어서 동작합니다. HTTPS에는 이 외에도 많은 기능이 있겠지만, OSI 7계층과 함께 이해한다면 좋은 내용이 될 것이라고 판단합니다. 다음에는 OSI 7계층에 대해서도 간단히 정리해봐야 할 것 같습니다. 감사합니다.</p>\n<h2 id=\"references\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/HTTP\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WIKI - HTTP</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/HTTPS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WIKI - HTTPS</a></li>\n<li><a href=\"https://namu.wiki/w/TLS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WIKI - TLS</a></li>\n<li><a href=\"https://www.verisign.com/ko_KR/website-presence/website-optimization/ssl-certificates/index.xhtml\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Versign - SSL</a></li>\n</ul>","id":"12f3407a-3398-5b44-9051-8d4f0cd92303","fields":{"slug":"network-http-http-vs-https의-차이-그리고-packet과-tsl-ssl"},"frontmatter":{"title":"[Network/Http] Http vs Https의 차이? 그리고 Packet과 TSL, SSL","date":"2018-04-20T00:00:00.000Z","author":"Seolhun","subTitle":"","banner":"/assets/covers/http.png","category":"Network","tags":["Network","Http","Https","Packet","TLS","SSL"]},"timeToRead":5}],"categoryName":"Network"}}}