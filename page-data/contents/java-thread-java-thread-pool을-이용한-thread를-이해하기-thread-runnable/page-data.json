{"componentChunkName":"component---src-templates-post-tsx","path":"/contents/java-thread-java-thread-pool을-이용한-thread를-이해하기-thread-runnable","webpackCompilationHash":"3421a461549ce11fe9c4","result":{"data":{"markdownRemark":{"html":"<p>안녕하세요, 설훈입니다.\n이번에는 Java의 Thread, Runnable, Task 등에 대해서 알아보겠습니다.</p>\n<h2 id=\"intro\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<ol>\n<li>Thread로 간단한 게임 프로젝트 진행 중 Thread에 대한 관리가 명확하지 않아 Thread Pool을 통해 Thread에 관리 가능정도와 효율성 장단점을 이해하고 싶었다.</li>\n<li>Multi Thread 간 자원공유가 이루어지는 방식에 대해 더 자세히 알아보고 싶었다.</li>\n<li>Thread Life Cycle에 대한 이해의 부족으로 필요한 메소드를 사용하지 못했으며, 이를 해결하기 위해 Life Cycle에 따른 상태관리와 필요한 메소드에 알아보고자 한다.</li>\n</ol>\n<h2 id=\"goal\"><a href=\"#goal\" aria-label=\"goal permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Goal</h2>\n<ol>\n<li>Java에서 제공하는 Executors를 통해 Thread Pool을 구현해보고 이에 대한 장단점을 이해한다.</li>\n<li>MultiThread를 예제를 통해 Thread의 작업 순서와 자원공유 등에 대한 필요지식을 이해한다.</li>\n<li>Thread에 Join, Wait, Notify, Yield 등의 API를 통해 Thread의 Life Cycle을 이해한다.</li>\n</ol>\n<h2 id=\"keywords\"><a href=\"#keywords\" aria-label=\"keywords permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Keywords</h2>\n<ol>\n<li>Thread\n스레드(thread)는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티스레드(multithread)라고 한다.</li>\n<li>Process\n프로세스(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 한다. 프로세스 관리는 운영 체제의 중요한 부분이 되었다.</li>\n<li>Process Vs Thread\n멀티프로세스와 멀티스레드는 양쪽 모두 여러 흐름이 동시에 진행된다는 공통점을 가지고 있다. 하지만 멀티프로세스에서 각 프로세스는 독립적으로 실행되며 각각 별개의 메모리를 차지하고 있는 것과 달리 멀티스레드는 프로세스 내의 메모리를 공유해 사용할 수 있다. 또한 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.</li>\n</ol>\n<p>멀티스레드의 다른 장점은 CPU가 여러 개일 경우에 각각의 CPU가 스레드 하나씩을 담당하는 방법으로 속도를 높일 수 있다는 것이다. 이러한 시스템에서는 여러 스레드가 실제 시간상으로 동시에 수행될 수 있기 때문이다.</p>\n<p>멀티스레드의 단점에는 각각의 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다는 것이 있다.</p>\n<ol start=\"4\">\n<li>Multi Tasking\n전산학 분야에서 멀티태스킹(multitasking) 또는 다중작업(이하 멀티태스킹)은 다수의 작업(혹은 프로세스, 이하 태스크)이 중앙 처리 장치(이하 CPU)와 같은 공용자원을 나누어 사용하는 것을 말한다. 엄밀히 말해 한 개의 CPU를 가진 개인용 컴퓨터가 특정 순간에 수행할 수 있는 태스크의 개수는 하나뿐이다. 따라서 멀티태스킹은 스케줄링이라는 방식을 사용하여 컴퓨터 사용자에게 병렬 연산이 이루어지는 것과 같은 환경을 제공한다. 스케줄링 방식은 CPU 사용시간을 일정한 기준에 따라 나누어 각 태스크가 사용할 수 있도록 분배한다. 분배받은 시간동안 태스크가 CPU를 사용할 때 다른 태스크들은 자신의 차례가 오기를 기다린다. 분배받은 시간이 종료되어 태스크가 사용하던 CPU를 다른 태스크가 사용할 수 있도록 재배정하는 것을 문맥교환이라 하는데 스케줄링에서 이 문맥교환이 충분히 자주 발생하게 되면 컴퓨터 사용자는 병렬 연산이 이루어진 것처럼 느끼게 된다.</li>\n</ol>\n<p>멀티태스킹은 다수의 CPU를 내장한 컴퓨터(즉, 멀티프로세서)에서도 유효한데, 멀티태스킹을 사용하게 되면 탑재한 CPU의 숫자보다 많은 수의 태스크를 동시에 수행할 수 있게 된다.</p>\n<p>일반적으로 운영 체제는 아래 나열된 스케줄링 방식중 하나를 채택해서 사용한다.\n멀티프로그래밍 시스템에서는 현재 실행되고 있는 태스크는 다른 외부 이벤트를 기다려야 하는 상황이 되거나, 컴퓨터의 스케줄러가 강제로 실행 중인 태스크를 중단시킬 때까지 계속 진행된다. 멀티 프로그램 시스템은 CPU 사용률을 극대화할 수 있도록 설계되었다.</p>\n<ul>\n<li>시분할 시스템에서는 현재 실행되고 있는 태스크가 스스로 혹은 하드웨어 인터럽트 따위의 외부적인 이유로 중앙 처리 장치의 점유를 포기해야 한다. 시분할 시스템은 다수의 프로그램이 거의 동시에 수행될 수 있도록 해준다. '시간을 분할한다'라는 표현은 단말에 위치한 사용자가 함께 공유할 수 있는 IBM사의 TSO, CP/CMS와 같은 컴퓨터를 가리키기 위해 쓰였다.</li>\n<li>실시간 시스템에서는 외부 이벤트가 발생하였을 때 몇 개의 대기 중인 태스크들이 CPU를 점유할 수 있도록 보장해 준다. 실시간 시스템은 시간 내에 처리하여야 하는 산업 로봇과 같은 기계적인 장치를 제어하기 위해 사용된다.</li>\n</ul>\n<p>동일한 시스템을 여러 명이 공유해서 쓰는 것을 나타내던 시분할이라는 용어는 개인용 컴퓨터와 워크스테이션의 발전으로 인해 멀티태스킹이라는 용어로 대체되어 특수한 경우를 제외하고 현재는 거의 사용되지 않는다.</p>\n<h2 id=\"contents\"><a href=\"#contents\" aria-label=\"contents permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contents</h2>\n<h4 id=\"1-thread와-runnable을-통한-thread-만들기-방식과-생성의-차이점-알아보기\"><a href=\"#1-thread%EC%99%80-runnable%EC%9D%84-%ED%86%B5%ED%95%9C-thread-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%EC%83%9D%EC%84%B1%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\"1 thread와 runnable을 통한 thread 만들기 방식과 생성의 차이점 알아보기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) Thread와 Runnable을 통한 Thread 만들기 방식과 생성의 차이점 알아보기.</h4>\n<h4 id=\"차이점\"><a href=\"#%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"차이점 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차이점.</h4>\n<ol>\n<li>Thread는 Class로서 Extends(상속), Runnable은 Interfacle로서 Implements(구현)을 사용한다.</li>\n<li>Thread 자체를 다시 만드는 것과 Thread에 작동되는 부분(run)을 Interface로 구현하는 것의 차이가 있다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">shooney<span class=\"token punctuation\">.</span>example<span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">.</span>extendsinterface</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadExntedsExample</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">/* Thread의 run method 재정의하기. */</span>\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">/* 작업내용 */</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> args<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">ThreadExntedsExample</span> threadExntedsExample<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadExntedsExample</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tthreadExntedsExample<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">shooney<span class=\"token punctuation\">.</span>example<span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">.</span>extendsinterface</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RunnableInterface</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">/* Interface의 run method 구현하기. */</span>\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">/* 작업내용 */</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> args<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">/* Interface Instance */</span>\n\t\t<span class=\"token class-name\">RunnableInterface</span> runnableInterface<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">RunnableInterface</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">/* Oracle 문서 : Runnable Interface는 Thread에 의해 실행될 class에 Implements 되어야 합니다. 이 클래스에는 인자가 없는 run() method를 재정의해아합니다.*/</span>\n\t\t<span class=\"token class-name\">Thread</span> thread<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnableInterface<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">setPriority</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token operator\">&lt;</span> <span class=\"token operator\">/</span>highlight  <span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n#### <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>과 <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>의 차이\n<span class=\"token operator\">-</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>메소드는 단순히 클래스에 오버라이딩 된 메소드를 호출해서 사용하는 것으로 생각하면 쉽다<span class=\"token punctuation\">.</span>\n<span class=\"token operator\">-</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>메소드는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택<span class=\"token punctuation\">(</span>공간<span class=\"token punctuation\">)</span>을 생성한 다음 <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>을 호출해서 그 안<span class=\"token punctuation\">(</span>스택<span class=\"token punctuation\">)</span>에 <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>이 저장되는 것이다<span class=\"token punctuation\">.</span> 즉<span class=\"token punctuation\">,</span> 쓰레드를 사용하기 위해 <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>를\n\n실행시키는 순간 쓰레드만의 독립적인 작업 공간인 호출스택이 만들어지는 것이다<span class=\"token punctuation\">.</span> 그 후에 호출 스택안에 각 실행하고자 하는 예를 들면 <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>과 같은 메소드들이 저장되는 것이다<span class=\"token punctuation\">.</span> 호출 스택에 있는 내용들이 모두 수행하고 나면 쓰레드는 호출스택 공간과 함께 메모리 상에서 소멸된다<span class=\"token punctuation\">.</span>\n\n#### <span class=\"token class-name\">Thread</span>의 우선순위<span class=\"token punctuation\">(</span><span class=\"token class-name\">Proiority</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">-</span> <span class=\"token class-name\">Thread</span>가 가질 수 있는 우선순위의 범위는 <span class=\"token number\">1</span> <span class=\"token operator\">~</span> <span class=\"token number\">10</span> 이며<span class=\"token punctuation\">,</span> 숫자가 높을수록 우선순위가 높다<span class=\"token punctuation\">.</span>\n<span class=\"token operator\">-</span> 우선순위라는 속성<span class=\"token punctuation\">(</span>멤버변수<span class=\"token punctuation\">)</span>을 가지고 있는데<span class=\"token punctuation\">,</span> 이 우선순위의 값에 따라 <span class=\"token class-name\">Thread</span>가 얻는 실행시간이 달라진다<span class=\"token punctuation\">.</span>\n<span class=\"token operator\">-</span> 수행하는 작업의 중요도에 따라 <span class=\"token class-name\">Thread</span>의 우선순위를 서로 다르게 지정하여 특정 <span class=\"token class-name\">Thread</span>가 더 많은 작업시간을 갖도록 할 수 있다<span class=\"token punctuation\">.</span>\n<span class=\"token operator\">-</span> <span class=\"token class-name\">Thread</span>의 우선순위는 <span class=\"token class-name\">Thread</span>를 생성한 <span class=\"token class-name\">Thread</span>로부터 상속받는다<span class=\"token punctuation\">.</span>\n\n### <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">Thread</span> pool을 이용한 <span class=\"token class-name\">Thread</span> 작동 방식 보기<span class=\"token punctuation\">.</span>\n```java\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadPool1</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> threadName<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPool1</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> threadName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>threadName<span class=\"token operator\">=</span>threadName<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">'의 '</span><span class=\"token operator\">+</span>threadName<span class=\"token operator\">+</span><span class=\"token string\">'이 시작되었습니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">sleepThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">'가 종료되었습니다'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sleepThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\te<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>threadName<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">ExecutorService</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">Executors</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainClass</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">/* 5개의 Pool을 Fix한다. */</span>\n\t\t<span class=\"token class-name\">ExecutorService</span> executorService<span class=\"token operator\">=</span><span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token class-name\">Runnable</span> doThread<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPool1</span><span class=\"token punctuation\">(</span><span class=\"token string\">'SleepThread'</span><span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\texecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>doThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token comment\">/* ExecutorService의 모든 작업 이후 다른 thread 호출을 10초 동안 차단합니다.\n\t\texecutorService.awaitTermination(10, TimeUnit.SECONDS);\n\t\t*/</span>\n\n\t\t<span class=\"token comment\">/* ExecutorService 종료 */</span>\n\t\texecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token comment\">/* ExecutorService 종료되었는지 확인. */</span>\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>executorService<span class=\"token punctuation\">.</span><span class=\"token function\">isTerminated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">'모든 Thread가 종료되었습니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<sub>\n    <p>- Result</p>\n    <img src='/assets/images/contents/20170422/1.jpg' width='100%' height='100%'>\n</sub>\n<h3 id=\"3-excutorservice-method-이해하기\"><a href=\"#3-excutorservice-method-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"3 excutorservice method 이해하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. ExcutorService Method 이해하기.</h3>\n<ul>\n<li>\n<p>shutdown()</p>\n<ul>\n<li>이 메소드는 Excuotrs의 작업을 기다리고 종료시킵니다. 다른 작업의 종료를 기다려줍니다.</li>\n</ul>\n</li>\n<li>\n<p>shutdownNow()</p>\n<ul>\n<li>이 메소드는 Excutors를 바로 종료시킵니다. 이 메소드는 다른 작업의 종료까지 기다려주지 않습니다. (위 에러에서 이 메소드를 선언 시 Sleep을 기다리지 않고 종료하기 때문에 InterruptedException에러를 발생시킵니다.)</li>\n</ul>\n</li>\n<li>\n<p>isTerminated()</p>\n<ul>\n<li>Executor의 프로세스가 모두 종료되었으면 True를 반환합니다.</li>\n</ul>\n</li>\n<li>\n<p>isShutdown()</p>\n<ul>\n<li>Executor의 shutdown () 메소드를 호출 한 경우 true를 반환합니다.</li>\n</ul>\n</li>\n<li>\n<p>awaitTermination(longtimeout, TimeUnitunit)</p>\n<ul>\n<li>Ex) executorService.awaitTermination(10, TimeUnit.SECONDS);</li>\n<li>이 메소드는 실행 프로그램의 작업이 종료되거나 시간 초과가 발생할 때까지 호출 스레드를 차단합니다.</li>\n</ul>\n</li>\n<li>\n<p>Executors 클래스는 ThreadPoolExecutor를 사용하는 ExecutorService의 간단한 구현을 제공하지만, ThreadPoolExecutor는 이보다 훨씬 많은 기능을 제공합니다. 우리는 ThreadPoolExecutor 인스턴스를 만들 때 생존 할 스레드 수를 지정할 수 있으며 스레드 풀의 크기를 제한하고 자체 RejectedExecutionHandler 구현을 만들어 작업자 큐에 들어 가지 않는 작업을 처리 할 수 있습니다.</p>\n<ul>\n<li>[Executors] (<a href=\"http://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html</a>)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-thread의-api를-통해-thread-life-cycle-이해하기\"><a href=\"#4-thread%EC%9D%98-api%EB%A5%BC-%ED%86%B5%ED%95%B4-thread-life-cycle-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"4 thread의 api를 통해 thread life cycle 이해하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Thread의 API를 통해 Thread Life cycle 이해하기.</h3>\n<ul>\n<li>\n<p>NEW</p>\n<ul>\n<li>쓰레드가 생성되고 아직 start()가 호출되지 않은 상태</li>\n</ul>\n</li>\n<li>\n<p>RUNNABLE</p>\n<ul>\n<li>실행 중 또는 실행 가능한 상태</li>\n</ul>\n</li>\n<li>\n<p>BLOCKED</p>\n<ul>\n<li>동기화블럭에 의해서 일시정지된 상태(LOCK이 풀릴 때 까지 기다리는 상태)</li>\n</ul>\n</li>\n<li>\n<p>WAITING, TIMED_WAITING</p>\n<ul>\n<li>쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnable) 일시 정지상태, TIMED_WAITING은 일시정지시간이 지정된 경우를 의미</li>\n</ul>\n</li>\n<li>\n<p>TERMINATED</p>\n<ul>\n<li>\n<p>쓰레드의 작업이 종료된 상태\n<sub></p>\n<p>- Result</p>\n<img src='/assets/images/contents/20170422/2.jpg' width='100%' height='100%'>\n</sub>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"life-cycle이해를-위한-method\"><a href=\"#life-cycle%EC%9D%B4%ED%95%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-method\" aria-label=\"life cycle이해를 위한 method permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle이해를 위한 Method</h4>\n<ul>\n<li>\n<p><code class=\"language-text\">void interrupt()</code></p>\n<ul>\n<li>sleep()이나 join()에 의해 일시정지상태인 쓰레드를 실행 대기 상태로 만든다.</li>\n<li>해당 쓰레드에서는 InterruptedException이 발생함으로써 일시정지상태를 벗어나게 된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">void join()</code></p>\n<ul>\n<li>\n<p>join() 메소드는 다른 Thread가 현재 진행중이라면 이 Thread의 완료를 기다리는 것이며, 진행중인 Thread가 완료되면 이후 실행된다. 현재 진행 중인 Thread 이후 join한다고 생각하면 쉽다.</p>\n<ul>\n<li><code class=\"language-text\">void join(long millis)</code></li>\n<li><code class=\"language-text\">void join(long millis, int nanos)</code></li>\n</ul>\n</li>\n<li>지정된 시간이 지나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">void resume()</code></p>\n<ul>\n<li>suspend()에 의해 일시정지상태에 있는 쓰레드를 실행대기 상태(Runnable)로 만든다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">static void sleep(long millis)</code></p>\n<ul>\n<li>지정된 시간(천분의 일초 단위)동안 쓰레드를 일시정지시킨다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">static void sleep(long millis, int nanos)</code></p>\n<ul>\n<li>지정한 시간이 지나고 나면, 자동적으로 다시 실행대기상태가 된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">void wait()</code></p>\n<ul>\n<li>객체 wait 메소드에는 3가지 변화가 있다.</li>\n<li>먼저, 다른 스레드가 현재 스레드를 깨우기 위해 notify 또는 notifyAll 메소드를 호출 할 때까지 무기한 대기하는 것</li>\n<li>나머지 하나는 현재 스레드가 깨어나기 전까지, 특정 시간(설정된)동안 기다립니다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">void stop()</code></p>\n<ul>\n<li>쓰레드를 즉시 종료시킨다. 교착상태(dead-lock)에 빠지기 쉽기 때문에 deprecated 되었다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">void suspend()</code></p>\n<ul>\n<li>쓰레드를 일시 정지시킨다. resume()을 호출하면 다시 쓰레드를 실행대기 상태(Runnable)로 만들 수 있다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">static void yield()</code></p>\n<ul>\n<li>실행 중에 다른 쓰레드에게 양보(yield)하고 실행대기상태가 된다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"outro\"><a href=\"#outro\" aria-label=\"outro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Outro</h2>\n<ul>\n<li>Thread와 Runnable의 차이는 Class와 Interface의 차이지만, 활용하는 방법에도 큰 차이가 있습니다. 특히, Thread Class를 통해 프로그래밍을 하다보면 동기화에 많은 Thread가 생성되어 Thread의 Syncronized, Debug 등 다양한 문제로 인해 Thread 관리에 어려움이 발생할 수 있습니다.</li>\n<li>특히, 병렬 작업 처리가 많아지면 Thread의 개수가 증가되고 그에 따른 Thread 생성과 스케줄링으로 인해 CPU가 바빠져 메모리 사용량이 늘어납니다. 따라서 어플리케이션의 성능이 저하됩니다. 갑작스런 병렬작업의 극대화로 인한 스레드 증폭을 막으려면 Thread Pool을 사용해야 합니다.</li>\n<li>이를 해결하기 위해 서는, Thread Pool은 작업 처리에 사용되는 Thread를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 Thread가 맡아 처리합니다. 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리해야 합니다.</li>\n<li>이 부분은 Thread pool을 통해 제한된 Thread을 생성하고, 정해진 Thread를 통해 Runnable Interface에  method(run())을 구현해주어 해당 Thread에 해당내용이 수행될 수 있게 해주는 것이 훨씬 더 효율적입니다. 정해진 Thread에 실행내용만 바꿔주는 것입니다. 100개의 Thread를 통해 100개의 실행내용을 실행하는 것이 더 빠를 수 있겠지만, 불필요한 메모리를 할당하게 되는 문제가 생기게 되며, 자원을 공유 할때, 데이터 동기화 문제나, 교착상태에 빠지는 문제가 발생할 수 있는 문제가 커집니다. 그리고, 필요한 Thread를 최소한으로 선언하고 관리하여 효율적으로 프로그램을 운영하기 위함입니다.</li>\n<li>Java Thread pool은 Runnable 쓰레드를 관리하고 작업자 쓰레드는 Queue에서 Runnable을 실행합니다. 그리고, java.util.concurrent.Executors는 java.util.concurrent.Executor 인터페이스의 구현을 제공하여 java에 Thread pool을 구현합니다.</li>\n</ul>\n<h2 id=\"references\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<ul>\n<li>[Wiki] (<a href=\"https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C</a>)</li>\n<li>[JournalDev] (<a href=\"http://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice</a>)</li>\n<li>[Thread-Runnable] (<a href=\"http://blog.daum.net/hughlee193/138\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://blog.daum.net/hughlee193/138</a>)</li>\n<li>[갱짱.study] (<a href=\"http://gangzzang.tistory.com/entry/Java-%EC%93%B0%EB%A0%88%EB%93%9CThread\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://gangzzang.tistory.com/entry/Java-쓰레드Thread</a>)</li>\n</ul>","fields":{"slug":"java-thread-java-thread-pool을-이용한-thread를-이해하기-thread-runnable"},"frontmatter":{"title":"[Java/Thread] Java Thread Pool을 이용한 Thread를 이해하기(Thread, Runnable)","author":"Seolhun","subTitle":null,"banner":"/assets/covers/java.png","category":"Java","tags":["Thread","Java","Task","Runnable"],"date":"2017.04.22"},"timeToRead":9}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"java-thread-java-thread-pool을-이용한-thread를-이해하기-thread-runnable","prev":{"excerpt":"안녕하세요, 설훈입니다.\n마리아 디비에 사용자 권한주는 방법에 대해서 알아보겠습니다. Intro Mysql을 처음 설치할 때 database root 계정으로 사용할 password를 설정한다. 하지만 시간이 오래 지나서 그때 설정한 password를 기억할 수 없다면 다음의 방법으로 재설정할 수 있다.(CentOS 7 기준) 실행중인 mysql service를 중지 시킨다.  Password를 검사하지 않도록 mysql…","html":"<p>안녕하세요, 설훈입니다.\n마리아 디비에 사용자 권한주는 방법에 대해서 알아보겠습니다.</p>\n<h1 id=\"intro\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h1>\n<p>Mysql을 처음 설치할 때 database root 계정으로 사용할 password를 설정한다. 하지만 시간이 오래 지나서 그때 설정한 password를 기억할 수 없다면 다음의 방법으로 재설정할 수 있다.(CentOS 7 기준)</p>\n<ol>\n<li>\n<p>실행중인 mysql service를 중지 시킨다.</p>\n<ul>\n<li><code class=\"language-text\">systemctl stop mysql</code></li>\n</ul>\n</li>\n<li>\n<p>Password를 검사하지 않도록 mysql 환경설정 파일을 수정한다.</p>\n<ul>\n<li><code class=\"language-text\">/etc/mysql/my.conf</code> file에 skip-grant-tables를 추가하면 password를 검사하지 않는다.</li>\n</ul>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\">#</span>\n<span class=\"token comment\"># Basic Settings</span>\n<span class=\"token comment\">#</span>\nuser         <span class=\"token operator\">=</span> mysql\npid-file     <span class=\"token operator\">=</span> /var/run/mysqld/mysqld.pid\nsocket       <span class=\"token operator\">=</span> /var/run/mysqld/mysqld.sock\nport         <span class=\"token operator\">=</span> <span class=\"token number\">3306</span>\nbasedir      <span class=\"token operator\">=</span> /usr\ndatadir      <span class=\"token operator\">=</span> /var/lib/mysql\ntmpdir       <span class=\"token operator\">=</span> /tmp\nlc-messages-dir <span class=\"token operator\">=</span> /usr/share/mysql\nskip-external-locking\nskip-grant-tables</code></pre></div>\n<ol start=\"3\">\n<li>\n<p>새로운 설정 값으로 mysql service를 실행한다.</p>\n<ul>\n<li><code class=\"language-text\">sudo systemctl start mysql</code></li>\n</ul>\n</li>\n<li>\n<p>root 계정으로 mysql database를 연다.</p>\n<ul>\n<li><code class=\"language-text\">mysql -uroot -p****(password)</code></li>\n</ul>\n</li>\n<li>\n<p>root password를 재설정한다.</p>\n<ul>\n<li><code class=\"language-text\">UPDATE user SET password=PASSWORD(&#39;ROOT_비밀번호&#39;) WHERE user=&#39;root&#39;;</code></li>\n</ul>\n</li>\n<li>\n<p>2번에서 설정했던 my.conf를 복원하고 mysql service를 재실행 시킨다.</p>\n<ul>\n<li><code class=\"language-text\">sudo systemctl restart mysql</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"원본\"><a href=\"#%EC%9B%90%EB%B3%B8\" aria-label=\"원본 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원본</h2>\n<ul>\n<li><a href=\"http://postitforhooney.tistory.com/entry/MySql-Mariadb-MYsql-%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B6%8C%ED%95%9C%EC%A3%BC%EA%B8%B0-%EB%B0%8F-%ED%99%95%EC%9D%B8?category=652294\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">PostIT</a></li>\n</ul>","id":"ea487d32-d204-55da-9e7a-a5a3ded414d1","fields":{"slug":"db-maria-db-분실한-mysql-root-password-재설정하기"},"frontmatter":{"title":"[DB/MariaDB] 분실한 mysql root password 재설정하기","date":"2017-01-19T00:00:00.000Z","author":"Seolhun","subTitle":"MariaDB에 root password 초기화","banner":"/assets/covers/mariadb.png","category":"Database","tags":["Database","Mariadb","Auth"]},"timeToRead":1},"next":{"excerpt":"안녕하세요, 설훈입니다.\n이번에는 Java의 Collection Framework에 대해서 알아보겠습니다. Intro 자바를 이용하여 프로그래밍을 하다보면 자료구조에 대한 필요성을 느끼게 된다. 특히, 이번 설문지 프로젝트를 통해 설문지를 구성하면서 자료를 담아내는 List와 Set, Map 등 기본지식의 부족을 느끼게 되었다. 이를 이해하기 위해서는, Java에 기본적으로 제공되는 Collection Framework…","html":"<p>안녕하세요, 설훈입니다.\n이번에는 Java의 Collection Framework에 대해서 알아보겠습니다.</p>\n<h2 id=\"intro\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>자바를 이용하여 프로그래밍을 하다보면 자료구조에 대한 필요성을 느끼게 된다. 특히, 이번 설문지 프로젝트를 통해 설문지를 구성하면서 자료를 담아내는 List와 Set, Map 등 기본지식의 부족을 느끼게 되었다. 이를 이해하기 위해서는, Java에 기본적으로 제공되는 Collection Framework를 이해할 필요가 있다고 생각했다.</p>\n<p>Collection Framework는 어떻게보면 자료구조의 기본 중에 기본이다. 이를 알지 못하고 프로그래밍을 하다보면, 한계에 봉착할 수 있다. 비전공자로서 실무부터 배우는 프로그래밍은 향 후 한계에 봉착된다. 현 나의 시점이 그러하며, 무엇인가 해결하기 위해 고민하던 끝에, 정보처리기사의 기본적인 내용 또는 전공자들이 4년 동안 배우는 기본 지식이 내게는 부족하구나라는 결론에 이르렀다. 이는 자료구조, 알고리즘, 운영체제 등의 기본지식의 중요성이다. 기본지식 없이 쌓아올리는 탑은 무너지기 마련이다. 그래서, 이를 먼저 해결하기 위해, Java의 Collection Framework를 이해해보고자 한다.</p>\n<h2 id=\"goal\"><a href=\"#goal\" aria-label=\"goal permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Goal</h2>\n<ul>\n<li>Collection Framework는 List와 Set의 Interface로 구성되어있다. 추가적으로 Map의 Interface로 구성된 다양한 Map들이 존재하지만, 이는 Collection Framework에 포함되지 않는다. 먼저, Collection Framework(List, Set)을 이해하고, 추가적으로 Map을 이해하여 올바른 자료구조를 사용하고자 한다.</li>\n<li>3개의 차이점과 장단점을 이해하고, 예제를 통해 여러가지 테스트를 하여 경험을 나누고자 한다.</li>\n</ul>\n<h2 id=\"contents\"><a href=\"#contents\" aria-label=\"contents permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contents</h2>\n<h4 id=\"1-java-collection-framework-구조\"><a href=\"#1-java-collection-framework-%EA%B5%AC%EC%A1%B0\" aria-label=\"1 java collection framework 구조 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) Java Collection Framework 구조</h4>\n<sub>\n    <p>- Collection Framework1</p>\n    <img src='/assets/images/contents/20170503/1.jpg' width='100%' height='100%'>\n</sub>\n<sub>\n    <p>- Collection Framework2</p>\n    <img src='/assets/images/contents/20170503/2.jpg' width='100%' height='100%'>\n</sub>\n<h2 id=\"3-1-list에-대해서\"><a href=\"#3-1-list%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\" aria-label=\"3 1 list에 대해서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. List에 대해서</h2>\n<ol>\n<li>객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공합니다.</li>\n<li>\n<p>List는 객체 자체를 저장하는 것이 아니라, 해당하는 인덱스에 객체의 주소를 참조하여 저장합니다.\n<sub></p>\n<p>- About List</p>\n<img src='/assets/images/contents/20170503/3.jpg' width='100%' height='100%'>\n</sub>\n</li>\n</ol>\n<h4 id=\"3-1-1-arraylist\"><a href=\"#3-1-1-arraylist\" aria-label=\"3 1 1 arraylist permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1-1. ArrayList</h4>\n<ol>\n<li>ArratList는 저장 용량을 초과한 객체들이 들어오면 자동적으로 저장용량이 늘어난다. (index 자동 증가, 초기 10)</li>\n<li>ArrayList 초기값은 인덱스 0에 삽입된다.</li>\n<li>특정 인덱스에 객체를 삽입하면 해당 인덱스 뒤에 인덱스가 차례대로 1씩 증가./감소한다. 즉, 객체의 삽입/삭제가 자주 있을 때에 ArrayList는 비효율적이다. => LinkedList가 효율적</li>\n</ol>\n<h4 id=\"3-1-2-linkedlist\"><a href=\"#3-1-2-linkedlist\" aria-label=\"3 1 2 linkedlist permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1-2. LinkedList</h4>\n<ol>\n<li>LinkedList는 인접 참조를 링크해서 체인처럼 관리한다.</li>\n<li>LinkedList는 특정 인덱스의 객체를 제거하면, 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 즉, 위에 ArrayList에서 얘기했던 것처럼 삽입/삭제가 빈번히 있을 때 LinkedList를 쓰는것이 효율적이다.</li>\n</ol>\n<sub>\n    <p>- LinkedList</p>\n    <img src='/assets/images/contents/20170503/4.jpg' width='100%' height='100%'>\n</sub>\n<sub>\n    <p>- LinkedList vs ArrayList</p>\n    <img src='/assets/images/contents/20170503/5.jpg' width='100%' height='100%'>\n</sub>\n<h4 id=\"3-1-3-vector\"><a href=\"#3-1-3-vector\" aria-label=\"3 1 3 vector permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1-3. Vector</h4>\n<ol>\n<li>Vector는 ArrayList와 같은 구조를 갖고있다.</li>\n<li>차이점은 Vector는 동기화(Syncronized)된 메소드로 구성되어있기 때문에 Multi Thread가 동시에 이 메소드를 실행할 수 없다. 그러므로, 하나의 스레드가 실행을 완료해야만 다른 스레드가 실행할 수 있다. (Thread safe)</li>\n</ol>\n<h2 id=\"3-2-set에-대해서\"><a href=\"#3-2-set%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\" aria-label=\"3 2 set에 대해서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2. Set에 대해서</h2>\n<ol>\n<li>Set Collection은 List처럼 Index로 저장 순서를 유지하지 않습니다.</li>\n<li>객체를 중복 저장할 수 없으며, 하나의 Null만 존재합니다.</li>\n</ol>\n<sub>\n    <p>- Set</p>\n    <img src='/assets/images/contents/20170503/6.jpg' width='100%' height='100%'>\n</sub>\n<h4 id=\"3-2-1-hashset\"><a href=\"#3-2-1-hashset\" aria-label=\"3 2 1 hashset permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2-1. HashSet</h4>\n<ol>\n<li>순서 없이 저장하고, 동일한 객체는 중복 저장하지 않는다.</li>\n<li>동일한 객체란, 객체를 저장하기 전에 hashcode() 메소드를 호출해서 해시코드를 얻어내며, 이미 저장되어 있는 객체들의 해시코드와 비교한다. 만약, 동일한 hashcode가 있다면 다시 equals() 메소드로 객체를 비교해서 ture가 나오면 동일한 객체로 판단하고 중복저장을 하지 않는다.</li>\n</ol>\n<h4 id=\"3-2-2-treeset\"><a href=\"#3-2-2-treeset\" aria-label=\"3 2 2 treeset permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2-2. TreeSet</h4>\n<sub>\n    <p>- TreeSet</p>\n    <img src='/assets/images/contents/20170503/7.jpg' width='100%' height='100%'>\n</sub>\n1. TreeSet은 이진트리(binary tree)를 기반으로한 Set Collection이다.\n2. TreeSet은 2개의 자식 노드를 참조하기 위한 2개의 변수로 구성된다.\n3. 또한, 객체를 저장하면 자동으로 정렬되는데 부모값과 비교해서 낮은 것은 왼쪽 자식 노드에, 높은 것은 오른쪽 자식 노드에 저장한다.\n4. Set 인터페이스 타입 변수에 대입해도 되지만 TreeSet 클래스 타입으로 대입한 이유는 객체를 찾거나 범위 검색과 관련된 메소드를 사요하기 위해서이다.\n<sub>\n    <p>- TreeSet의 검색 메소드</p>\n    <img src='/assets/images/contents/20170503/8.jpg' width='100%' height='100%'>\n</sub>\n<h2 id=\"3-3-map에-대해서\"><a href=\"#3-3-map%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\" aria-label=\"3 3 map에 대해서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3. Map에 대해서</h2>\n<ul>\n<li>\n<p>Key와 Value를 저장하며, Key는 중복될 수 없다. 키와 값은 모두 객체이다. 만약, 기존에 저장된 키와 동일한 키로 값을 저장하면 기존 값은 없어지고 새로운 값으로 대체 된다.\n<sub></p>\n<p>- Map</p>\n<img src='/assets/images/contents/20170503/9.jpg' width='100%' height='100%'>\n</sub>\n</li>\n</ul>\n<h4 id=\"3-3-1-hashmap\"><a href=\"#3-3-1-hashmap\" aria-label=\"3 3 1 hashmap permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3-1. HashMap</h4>\n<ol>\n<li>HashMap의 키로 사용할 객체는 hashCode()와 equlas() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 한다.</li>\n<li>키 값은 주로 String을 사용하지만, Object는 모든 키가 될 수 있다.</li>\n</ol>\n<h4 id=\"3-3-2-hashtable\"><a href=\"#3-3-2-hashtable\" aria-label=\"3 3 2 hashtable permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3-2. HashTable</h4>\n<ol>\n<li>HashMap과 동일 구조를 갖고 있어, hashCode()와 equals() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 한다.</li>\n<li>HashMap과의 차이점은 동기화된(Syncronized) 메소드로 구성되어 있어, Multi Thread 환경에서 안전하게 객체를 추가/삭제 등이 가능하다.(Thread safe), (ArrayList와 Vector의 관계와 유사)</li>\n</ol>\n<h4 id=\"3-3-3-properties\"><a href=\"#3-3-3-properties\" aria-label=\"3 3 3 properties permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3-3. Properties</h4>\n<p>HashTable의 하위 클래스이기 때문에 HashTable의 모든 특징을 그대로 가지고 있다.\n차이점은, HashTable은 키와 값을 다양한 타입으로 지정이 가능하지만, Properties는 키와 값을 String 타입으로 제한한 Collection 이다.\n주로, 옵션 정보, 다국어 정보 등을 저장한다.</p>\n<h4 id=\"3-3-4-treemap\"><a href=\"#3-3-4-treemap\" aria-label=\"3 3 4 treemap permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3-4. TreeMap</h4>\n<sub>\n    <p>- TreeMap</p>\n    <img src='/assets/images/contents/20170503/10.jpg' width='100%' height='100%'>\n</sub>\n1. TreeMap은 이진트리(binary tree)를 기반으로 한 Map Collection이다.\n2. TreeSet과 같은 구조를 같고 있지만, TreeSet과의 차이점은 키와 값이 저장된 Map.Entry를 저장하는 것.\n3. TreeSet과 동일하게 낮은 값이 왼쪽에 높은 값이 오른쪽 노드에 위치한다.\n<sub>\n    <p>- TreeMap의 검색 메소드</p>\n    <img src='/assets/images/contents/20170503/11.jpg' width='100%' height='100%'>\n</sub>\n<h2 id=\"ontro\"><a href=\"#ontro\" aria-label=\"ontro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ontro</h2>\n<p>각각의 자료구조가 어떻게 구현 되었는지를 아는 것은 중요하다. 하지만 최소한 어떻게 구현되었는지까지 모른다면, 각각의 구조가 언제 어떻게 사용되는지를 아는 것이 프로그래머로서 기본이라고 생각된다. 알아야 효율적으로 데이터를 관리/사용 할 수 있기 때문이다.</p>\n<p>이번 Collection Framework를 통해 List, Set, Map 등에 대해서 알아보았으며, 각각의 클래스와 메소드를 잘 이해하고 사용하는 기회가 될 것으로 판단된다. 특히, Multi Thread 환경과 검색을 위한 자료구조의 변화가 가장 큰 특이점으로 보여졌다.</p>\n<p>Syncronized Method를 구현해주어 문제없이 thread safe 환경에서 구축할 수 있는 Vector와 HashTable이 있다. 검색을 향상시키기 위한 index, 이진트리(binary tree), 앞뒤 참조 등 다양한 방법으로 차이점이 발생되었다.</p>\n<h2 id=\"5-origin-contents\"><a href=\"#5-origin-contents\" aria-label=\"5 origin contents permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Origin Contents</h2>\n<p><a href=\"http://postitforhooney.tistory.com/entry/JavaCollection-Java-Collection-Framework%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4%EB%A5%BC-%ED%86%B5%ED%95%B4-Data-Structure-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0?category=695112\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tistory - Seolhun Blog - Collection Framework</a></p>","id":"5246a88c-2fc5-570c-9aa9-82102459f821","fields":{"slug":"java-collection-java-collection-framework에-대한-이해를-통해-data-structure-이해하기"},"frontmatter":{"title":"[Java/Collection] Java Collection Framework에 대한 이해를 통해 Data Structure 이해하기","date":"2017-05-03T00:00:00.000Z","author":"Seolhun","subTitle":null,"banner":"/assets/covers/java.png","category":"Datastructure","tags":["Datastructure","Java","Collection"]},"timeToRead":4}}}}