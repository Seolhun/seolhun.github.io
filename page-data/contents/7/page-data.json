{"componentChunkName":"component---src-templates-blog-tsx","path":"/contents/7","webpackCompilationHash":"aab94e70ae11ee7caf13","result":{"data":{"allMarkdownRemark":{"totalCount":66,"edges":[{"node":{"fields":{"slug":"algorithm-java-codility-counting-elevator-movements"},"frontmatter":{"title":"[Algorithm/Java] Codility - Counting Elevator Movements","date":"2018.04.08","category":"Algorithm","tags":["Algorithm","Java"],"banner":"/assets/covers/java.png"},"excerpt":"이번에 Codility에서 Elevator로 사람을 운반하는 알고리즘을 만드는 문제입니다. Queue를 사용해야 할 것으로 보이며 Queue를 이용하여 풀어보겠습니다. 1. Question 2. Process Waiting People Queue 만들기 Elevator 한계선 조건 만들기 Waiting People Queue에서 Elevator Queue로 이동 Elevator Queue에 각 층마다 돌아가고 Elevator queue가 비우면 1층으로 복귀 반복하여 Waiting Queue가 없어지면 완료 3. Code…","timeToRead":4}},{"node":{"fields":{"slug":"algorithm-javascript-programmers-algorithm-야근지수"},"frontmatter":{"title":"[Algorithm/Javascript] Programmers Algorithm 야근지수","date":"2018.04.07","category":"Algorithm","tags":["Algorithm","Javascript","Javascript"],"banner":"/assets/covers/js.png"},"excerpt":"이번에는 Java로 000 문제 야근지수를 구현해보도록 하겠습니다.\n 1. Question function solution(A);\nthat, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A. For example, given A = 1, 3, 6, 4, 1, 2, the function should return 5. Given A = 1, 2, 3, the function…","timeToRead":1}},{"node":{"fields":{"slug":"algorithm-js-배열에서-사용하면-좋을-javascript-메소드들"},"frontmatter":{"title":"[Algorithm/JS] 배열에서 사용하면 좋을 Javascript 메소드들","date":"2018.04.07","category":"Algorithm","tags":["Algorithm","JS","Anti Pattern","Methods"],"banner":"/assets/covers/js.png"},"excerpt":"이번에는 알고리즘을 풀 때, 배열에 필요한 메소드들을 정리해볼까 합니다. 이러한 메소드들을 숙지하면 안티패턴으로 또 구성할 필요없이 잘 짜여진 코드들을 이용할 수 있습니다. Intro 배열 메소드에는 사용하면 생산성이 많이 올라가는 메소드가 많습니다. 특히, 배열은 알고리즘 문제에서 기본적으로 주어지는 문제타입입니다. 그렇기에 배열 관련 메소드를 이해하면 문제를 알고리즘을 푸는데 많은 도움을 받을 수 있습니다. 이번 시간을 통해 배열에 기본 내장된 메소드를 숙지하여 생산성과 가독성을 높이면 좋을 것 같습니다. Contents…","timeToRead":4}},{"node":{"fields":{"slug":"javascript-es-6-es-6-부터-등장하는-개발자가-알아야-할-특징-part-2"},"frontmatter":{"title":"[Javascript/ES6] ES6부터 등장하는 개발자가 알아야 할 특징 - Part 2","date":"2018.04.07","category":"Javascript","tags":["Javascript","ES6","Feature"],"banner":"/assets/covers/js.png"},"excerpt":"이번에는 저번 시간에 작성한 ES6 Featur Part1에 이어 Part 2에 해당되는 내용을 정리해볼까 합니다. 간단히 정리하였지만 필요한 기능들을 숙지하면 큰 도움이 될 것 같습니다. Intro ES6 특징 - Part 1을 먼저 정리하였으니, 2파트 모두 확인하실 분들은 블로그를 확인해주세요. Part 1 Block-Scoped Constructs  and  Arrow Functions Default Parameters Enhanced Object Literals Part 2 New Built-In Methods…","timeToRead":4}},{"node":{"fields":{"slug":"algorithm-javascript-모든-배열의-값을-가져오는-algorithm-flatten"},"frontmatter":{"title":"[Algorithm/Javascript] 모든 배열의 값을 가져오는 Algorithm(Flatten)","date":"2018.04.06","category":"Algorithm","tags":["Algorithm","Javascript","Javascript"],"banner":"/assets/covers/js.png"},"excerpt":"이번에 렌딧 면접간 모든 배열의 값을 출력하는 알고리즘이었습니다. 어려운 문제는 아니었으나 제가 넓은 사고를 하지 못해 쉽게는 풀지 못했던 것 같습니다. 이번 알고리즘을 통해 ES6의 Rest 기능으로 더 많은 알고리즘의 기회가 생겼음을 알았고 이와 관련하여 글을 작성해보고자 합니다. 1. Question 주어진 배열 안에 존재하는 배열 값 모두를 1차원 배열에 값으로 만드는 문제입니다. 해결방법의 시간 복잡도는 이다. 주어진 배열 값을 모두 확인하며 처리 한후, 하나의 값으로 모으면서 의 복잡도를 갖게 된다. 2. Process…","timeToRead":1}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"limit":5,"skip":30,"totalPages":14,"currentPage":7}}}