{"componentChunkName":"component---src-templates-blog-tsx","path":"/contents/9","webpackCompilationHash":"e659d2a4bb5ac98f5ba4","result":{"data":{"allMarkdownRemark":{"totalCount":65,"edges":[{"node":{"fields":{"slug":"algorithm-javascript-hacker-rank-find-the-median"},"frontmatter":{"title":"[Algorithm/Javascript] HackerRank - FindTheMedian","date":"2018.03.26","category":"Algorithm","tags":["Algorithm","Javascript","HackerRank","Sort","FindTheMedian"],"banner":"/assets/covers/js.png"},"excerpt":"저번 시간에 ClosestNumbers 문제를 풀어보았습니다.\n이번에는 FindTheMedian 알고리즘을 풀어보겠습니다.\n주어진 배열 값 안에서 배열의 가운데 값을 찾는 알고리즘입니다.\nHackerRank - Sort - FindTheMedian 1. Question Sample Input Sample Output 2. Process…","timeToRead":1}},{"node":{"fields":{"slug":"algorithm-javascript-hacker-rank-closest-numbers"},"frontmatter":{"title":"[Algorithm/Javascript] HackerRank - ClosestNumbers","date":"2018.03.25","category":"Algorithm","tags":["Algorithm","Javascript","HackerRank","Sort","ClosestNumbers"],"banner":"/assets/covers/js.png"},"excerpt":"저번 시간에 Counting Sort 2문제를 모두 풀어보았습니다. 이번에는 ClosestNumbers 알고리즘을 풀어보겠습니다.\n두 값의 차가 가장 적은 두 수를 찾는 것입니다. 만약, 차가 다른 것과 같다면 같이 보여주어야 합니다.\nHackerRank - Sort - ClosestNumbers 1. Question Sample Input #…","timeToRead":2}},{"node":{"fields":{"slug":"algorithm-javascript-hacker-rank-counting-sort-part-2"},"frontmatter":{"title":"[Algorithm/Javascript] HackerRank - CountingSort Part 2","date":"2018.03.24","category":"Algorithm","tags":["Algorithm","Javascript","HackerRank","Sort","Counting"],"banner":"/assets/covers/js.png"},"excerpt":"저번 시간에 Counting Sort Part 1을 풀어보았습니다.\n이번에는 Counting Sort Part 2를 풀어보겠습니다. 이번 알고리즘은 개수에 상관없이 정렬하면 될것으로 보입니다.\nHackerRank - Sort - CountingSort Part 2 1. Question Sample Input Sample Output 2. Process…","timeToRead":1}},{"node":{"fields":{"slug":"algorithm-javascript-hacker-rank-counting-sort-part-1"},"frontmatter":{"title":"[Algorithm/Javascript] HackerRank - CountingSort Part 1","date":"2018.03.24","category":"Algorithm","tags":["Algorithm","Javascript","HackerRank","Sort","Counting"],"banner":"/assets/covers/js.png"},"excerpt":"저번 시간에 삽입정렬 2개 모두 풀어보았습니다.\n이번에는 배열 안에서 같은 값의 개수를 파악하는 CountingSort를 풀어보겠습니다. 정렬되지 않은 값들에서 0~99까지의 번호순으로 개수를 파악하는 알고리즘\nHackerRank - Sort - CountingSort Part 1 1. Question Sample Input Sample Output…","timeToRead":1}},{"node":{"fields":{"slug":"java-thread-data-structure-java-thread와-queue를-이용여-producer-consumer-패턴-구현하기-part-1"},"frontmatter":{"title":"[Java/Thread/DataStructure] Java Thread와 Queue를 이용여 Producer & Consumer 패턴 구현하기: Part1","date":"2018.03.23","category":"Java","tags":["Java","Thread","Qeue","Producer","Consumer","Pattern","Concurrency"],"banner":"/assets/covers/java.png"},"excerpt":"안녕하세요, 설훈입니다.\n이번에는 Java Thread와 Queue를 이용하여 Producer & Consumer Pattern에 대해서 작성해볼까 합니다. Intro 제가 생각하는 프로그래밍은 끊임없는 대화의 연속이라고 생각합니다. 하나의 코드들이 서로 끊임없이 소통해야지만 프로그램이 완성되는 것이죠.\n즉, 프로그램에서 미리 정의된 작업(Task…","timeToRead":4}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"limit":5,"skip":40,"totalPages":13,"currentPage":9}}}